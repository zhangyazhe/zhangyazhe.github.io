<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="课程笔记, CSP, 随笔, 转载文章, git, linux">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    CSP零碎知识点整理 |
    
    知 昂 张</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="知 昂 张" type="application/atom+xml">
</head>

<body>
<main class="content">
  <section class="outer">
  

<article id="post-CSP零碎知识点整理" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CSP零碎知识点整理
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/01/30/CSP%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-01-30T03:54:35.000Z" itemprop="datePublished">2020-01-30</time>
</a>
        
      </div>
    

    
      




    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>摘要：</p>
<p>祝看过这篇博文的同学CSP都能考到300以上(￣▽￣)~*</p>
<p>笔记里面主要记录的是我在准备CSP过程中遇到过得问题或者学习到的新知识，涵盖C语言、C++、算法等方面内容，由于我是遇到啥写啥，所以内容有点散，不过还是希望所有读过的同学都能有所收获~</p>
<a id="more"></a>

<ul>
<li>判断整数是奇数还是偶数时，可以让这个数与1进行按位与，即num&amp;1，如果结果为1，则num为奇数，否则为偶数</li>
<li>进行整数向浮点数的转换时，可以乘以1.0</li>
<li>C++ vector容器浅析 <a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a><br>删除指定元素可以这样做： 删除第二个元素 (vec[1])<br>vec.erase(vec.begin() + 1);</li>
<li>C++ list总结 <a href="https://www.cnblogs.com/loleina/p/5179677.html" target="_blank" rel="noopener">https://www.cnblogs.com/loleina/p/5179677.html</a></li>
<li>C++ set成员函数用法总结 <a href="https://blog.csdn.net/qq_34243930/article/details/81481929" target="_blank" rel="noopener">https://blog.csdn.net/qq_34243930/article/details/81481929</a><br>set中的元素可以是pair，排序时，先按照first排序，相同的话再按照second排序。元素为pair时，set的find函数就不太好用了，这时可以使用upper_bound函数或者lower_bound()函数，函数中的比较规则也是先看first再看second。lower_bound()函数返回的是第一个不小于给定元素key的位置，upper_bound() 函数返回的是第一个大于给定元素key的位置。<br>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set&lt;pair&lt;int, int&gt; &gt; st;</span><br><span class="line">set&lt;pair&lt;int, int&gt; &gt;::iterator st_it;</span><br><span class="line">st.insert(make_pair(2, 6));</span><br><span class="line">st.insert(make_pair(1, 5)); </span><br><span class="line">st.insert(make_pair(3, 7));       </span><br><span class="line">st.insert(make_pair(4, 8));</span><br><span class="line">cout &lt;&lt; &quot;遍历输出&quot; &lt;&lt; endl;</span><br><span class="line">for(st_it &#x3D; st.begin(); st_it !&#x3D; st.end(); st_it++)&#123;</span><br><span class="line">    cout &lt;&lt; st_it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">st_it &#x3D; st.lower_bound(make_pair(3, 7));</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; &quot;查找输出&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; st_it-&gt;second;</span><br></pre></td></tr></table></figure></li>
<li>C++ map的基本操作和使用 <a href="https://blog.csdn.net/qq_40914533/article/details/81981467" target="_blank" rel="noopener">https://blog.csdn.net/qq_40914533/article/details/81981467</a></li>
<li>qsort()函数 <a href="https://www.runoob.com/cprogramming/c-function-qsort.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-function-qsort.html</a></li>
<li>C++ sort()函数 <a href="https://www.cnblogs.com/TX980502/p/8528840.html" target="_blank" rel="noopener">https://www.cnblogs.com/TX980502/p/8528840.html</a><br>sort和qsort之间更推荐sort<br>概述：需要头文件<algorithm><br>语法描述：sort（begin，end，cmp），cmp参数可以没有，如果没有默认非降序排序，end为最后一个元素再后面一个位置的指针<br>对于cmp函数的编写，如果return a&gt;b; 则理解为使用&gt;号对元素进行排序。<br>其实对于这么简单的任务（类型支持“&lt;”、“&gt;”等比较运算符），完全没必要自己写一个类出来。标准库里已经有现成的了，就在functional里，include进来就行了。functional提供了一堆基于模板的比较函数对象。它们是（看名字就知道意思了）：equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>。对于这个问题来说，greater和less就足够了，直接拿过来用：<br>升序：sort(begin,end,less<data-type>());<br>降序：sort(begin,end,greater<data-type>()).<br>详见文中：字符串内的字符排序、字符串之间排序、结构体的二级排序</li>
<li>C++ 运算符的重载 <a href="https://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-overloading.html</a></li>
<li>C++ 关系运算符的重载 <a href="https://www.runoob.com/cplusplus/relational-operators-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/relational-operators-overloading.html</a></li>
<li>C++ 优先队列priority_queue用法详解 <a href="https://blog.csdn.net/weixin_36888577/article/details/79937886" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36888577/article/details/79937886</a><br>优先队列中的内容默认是从大到小</li>
<li>一个函数实现16进制的数字与字符之间的转换：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;关键在于形参是char类型</span><br><span class="line">char getc(char c)&#123;   </span><br><span class="line">    if(c&lt;10)   </span><br><span class="line">        return c+&#39;0&#39;;   </span><br><span class="line">    else if(c&lt;&#x3D;16)   </span><br><span class="line">        return c+&#39;A&#39;-10;   </span><br><span class="line">    else if(c&lt;&#x3D;&#39;9&#39;)   </span><br><span class="line">        return c-&#39;0&#39;;   </span><br><span class="line">    else if(c&lt;&#x3D;&#39;F&#39;)   </span><br><span class="line">        return c-&#39;A&#39;+10;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对两个字符进行异或可以使用这个函数：ret=getc(getc(a[i])^getc(b[i]));先将字符转换为整数，进行异或之后再转换回字符</li>
<li>可以用宏来定义for循环，简化代码：#define UP(x) for(uint32_t i=0;i&lt;x;i++)   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UP(8)&#123;</span><br><span class="line">        a[i]&#x3D;getc(getc(a[i])^getc(b[i]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>C++ 引用：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br>引用很容易与指针混淆，它们之间有三个主要的不同：   <ul>
<li>不存在空引用。引用必须连接到一块合法的内存。   </li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。   </li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化</li>
</ul>
</li>
<li>C++  把引用作为返回值 <a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/returning-values-by-reference.html</a></li>
<li>C++ 把引用作为参数 <a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/passing-parameters-by-references.html</a></li>
<li>namespace以及using的用法 <a href="https://www.runoob.com/cplusplus/cpp-namespaces.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-namespaces.html</a></li>
<li>C++ cout：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::showpoint);  &#x2F;&#x2F; 设左对齐，以一般实数方式显示</span><br><span class="line">    cout.precision(5);       &#x2F;&#x2F; 设置除小数点外有五位有效数字 </span><br><span class="line">    cout&lt;&lt;123.456789&lt;&lt;endl;</span><br><span class="line">    cout.width(10);          &#x2F;&#x2F; 设置显示域宽10 </span><br><span class="line">    cout.fill(&#39;*&#39;);          &#x2F;&#x2F; 在显示区域空白处用*填充</span><br><span class="line">    cout&lt;&lt;resetiosflags(ios::left);  &#x2F;&#x2F; 清除状态左对齐</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::right);   &#x2F;&#x2F; 设置右对齐</span><br><span class="line">    cout&lt;&lt;123.456789&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::fixed);    &#x2F;&#x2F; 设左对齐，以固定小数位显示</span><br><span class="line">    cout.precision(3);    &#x2F;&#x2F; 设置实数显示三位小数</span><br><span class="line">    cout&lt;&lt;999.123456&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;resetiosflags(ios::left|ios::fixed);  &#x2F;&#x2F;清除状态左对齐和定点格式</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::scientific);    &#x2F;&#x2F;设置左对齐，以科学技术法显示 </span><br><span class="line">    cout.precision(3);   &#x2F;&#x2F;设置保留三位小数</span><br><span class="line">    cout&lt;&lt;123.45678&lt;&lt;endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果为：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123.46</span><br><span class="line">****123.46</span><br><span class="line">999.123</span><br><span class="line">1.235e+02</span><br></pre></td></tr></table></figure>
setiosflags中的常见标志：<br>boolalpha    可以使用单词”true”和”false”进行输入/输出的布尔值.<br>oct    用八进制格式显示数值.<br>dec    用十进制格式显示数值.<br>hex    用十六进制格式显示数值.<br>left    输出调整为左对齐.<br>right    输出调整为右对齐.<br>scientific    用科学记数法显示浮点数.<br>fixed    用正常的记数方法显示浮点数(与科学计数法相对应).<br>showbase    输出时显示所有数值的基数.<br>showpoint    显示小数点和额外的零，即使不需要.<br>showpos    在非负数值前面显示”＋（正号）”.<br>skipws    当从一个流进行读取时，跳过空白字符(spaces, tabs, newlines).<br>unitbuf    在每次插入以后，清空缓冲区.<br>internal    将填充字符回到符号和数值之间.<br>uppercase    以大写的形式显示科学记数法中的”e”和十六进制格式的”x”.   </li>
<li><strong>C++</strong> 输入：<ul>
<li>cin<br>输入时，以空格、tab、回车作为分隔符。当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，<strong>cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&gt;&gt;不做处理</strong></li>
<li>cin.getline()<br>用于读取字符串，读到的字符串是c++风格的string类型。<br>cin.getline默认读取到回车时终止，并将回车符号转换为\0存入字符串，同时将回车符从缓冲区中删除。空格也会被读取<br>函数原型有两个：   </li>
</ul>
</li>
</ul>
<p><em>//s是存放读取到的字符串的数组，count是读取长度<br>istream&amp; getline(char</em> s, streamsize count); //默认以换行符结束<br>istream&amp; getline(char* s, streamsize count, char delim);//delim为规定的结束符*   </p>
<ul>
<li>getline()<br>getline(cin, str)与cin.getline(str, num)作用相同，都可以读取空格，默认以回车结束。但是cin.getline的str要求是字符数组，且必须要指定num。而getline的str是string类型的变量，而且不需要指定长度。所以推荐使用getline。</li>
<li>cin.get<br>使用cin.get读取字符串时，可以这样使用：<br>ch = cin.get();<br>cin.get(ch);<br>或者直接cin.get()表示不将输入读取到任何变量，只是用来阻塞或者清除多余回车<br>cin.get()也可以用于读取字符串，不建议使用</li>
<li>gets<br>不建议使用</li>
<li>综上所述，普通输入用cin，读取字符串用getline()，读取字符用cin.get()<ul>
<li>ios::sync_with_stdio(false)可以用来提高cin和cout的速度</li>
<li>C++ 字符串<br>Cpp提供了两种类型的字符串表示形式：一种是C风格的字符串，另一种是C++风格的string类型字符串 </li>
<li>头文件<string><cstring>之间的区别：cstring是c语言中的string.h的c++版本，用法相同，用于处理C语言形式的字符串。引用string后就可以使用string类型（其实不引用也可以使用string类型），同时可以使用下面的string类中的函数。在处理字符串时，需要注意C++与c类型的字符串之间的区别，平时尽量只使用c++类型的字符串，必要时可以使用string类中的data()或者c_str()函数将string类型的字符串转化为c类型的字符串，两种方法的不同之处是，c_str()转换后会在最后加\0，而data()不会。</li>
<li>c_str()应该这样用: char c[20]; string s=”1234”; strcpy(c,s.c_str()); 这样才不会出错,c_str()返回的是一个临时指针,不能对其进行操作</li>
<li>C++ string类   </li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/Draymonder/p/6944479.html" target="_blank" rel="noopener">https://www.cnblogs.com/Draymonder/p/6944479.html</a></li>
<li>构造函数(Constructors)<br>语法:<br>string();<br>string( size_type length, char ch );<br>string( const char *str );参数是c形式字符串，可以实现c形式字符串到c++形式字符串的转换<br>string( const char *str, size_type length );<br>string( string &amp;str, size_type index, size_type length );<br>string( input_iterator start, input_iterator end );<br>字符串的构造函数创建一个新字符串，包括:<br>以length为长度的ch的拷贝（即length个ch）<br>以str为初值 (长度任意),<br>以index为索引开始的子串，长度为length, 或者<br>以从start到end的元素为初值.<br>例如,<br>string str1( 5, ‘c’ );<br>string str2( “Now is the time…” );<br>string str3( str2, 11, 4 );<br>cout &lt;&lt; str1 &lt;&lt; endl;<br>cout &lt;&lt; str2 &lt;&lt; endl;<br>cout &lt;&lt; str3 &lt;&lt; endl;<br>显示<br>ccccc<br>Now is the time…<br>time   </li>
<li>对字符串赋值方法很多，例如：<br>string s1(“hello”), s2;<br>s2 = s1;<br>或者用assign函数s2.assign(s1)</li>
<li>求字符串长度可以用.length()也可以用.size()</li>
<li>除了使用+、+=来连接字符串之外，还可以用append()函数在字符串末尾添加内容</li>
<li>字符串比较可以使用&gt; &lt; &gt;= &lt;=等等，比较的不是字符串长度，而是一位一位地比较字母的大小。<ul>
<li>201709_2：需要进行多重排序时，可以将排序依据包装到一个结构体里面，然后编写cmp函数，利用sort函数进行排序</li>
<li>什么是标准模板库（STL）？<br>(1)C++标准模板库与C++标准库的关系<br>C++标准模板库其实属于C++标准库的一部分，C++标准模板库主要是定义了标准模板的定义与声明，而这些模板主要都是<br>类模板，我们可以调用这些模板来定义一个具体的类；与之前的自己手动创建一个函数模版或者是类模板不一样，我们使用了<br>STL就不用自己来创建模板了，这些模板都定义在标准模板库中，我们只需要学会怎么使用这些类模板来定义一个具体的类，<br>然后能够使用类提供的各种方法来处理数据。<br>(2)STL六大组件：容器（containers）、算法（algorithms）、迭代器（iterators）、函数对象（functors）、适配器（adapters）、分配器（allocators）</li>
<li>在C++中，结构体可以有构造函数。例如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct ROLE&#123;</span><br><span class="line">    int health;</span><br><span class="line">    int attack;</span><br><span class="line">    ROLE()&#123;health &#x3D; 0; attack &#x3D; -1;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int r,c,dist;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(int r,int c,int dist):r(r),c(c),dist(dist)&#123;&#125;&#x2F;&#x2F;r(r)表示将r赋值给变量r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在C++中，定义结构体时不需要使用typedef，创建一个新的结构体变量的时候也不需要再加上struct，直接使用结构体的名字即可。例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123; &#x2F;&#x2F; 声明结构体</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a_st;  &#x2F;&#x2F;定义结构体</span><br><span class="line">A* a_p; &#x2F;&#x2F; 定义结构体指针</span><br></pre></td></tr></table></figure></li>
<li>使用#ifdef提高效率，例如<br>int main()<br>{<br>#ifdef LOCAL<br>freopen(“datain.txt”,”r”,stdin);<br>#endif // LOCAL<br>run();<br>ans();<br>return 0;<br>}<br>如果在前面已经有#define LOCAL，那么就会执行freopen，否则就直接执行endif后面的语句。在本地测试时，要在前面加上#define LOCAL，这样只需要将测试用例写到datain.txt中，不需要每次都手动输入。提交时，将#define LOCAL删除。</li>
<li>使用stringstream进行数据转换（int-&gt;string）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    std::string result;</span><br><span class="line">    int i &#x3D; 1000;</span><br><span class="line">    stream &lt;&lt; i; &#x2F;&#x2F;将int输入流</span><br><span class="line">    stream &gt;&gt; result; &#x2F;&#x2F;从stream中抽取前面插入的int值</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; &#x2F;&#x2F; print the string &quot;1000&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stringstream进行数据类型转换(int-&gt;char*)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    char result[8] ;</span><br><span class="line">    stream &lt;&lt; 8888; &#x2F;&#x2F;向stream中插入8888</span><br><span class="line">    stream &gt;&gt; result; &#x2F;&#x2F;抽取stream中的值到result</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; &#x2F;&#x2F; 屏幕显示 &quot;8888&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stringstream进行数据类型转换()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">＃i nclude &lt;iostream&gt; </span><br><span class="line">＃i nclude &lt;sstream&gt; </span><br><span class="line">＃i nclude &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">stringstream sstr; </span><br><span class="line">string name &#x3D; &quot;colinguan&quot;; </span><br><span class="line">char cname[200]; </span><br><span class="line">sstr&lt;&lt;name; </span><br><span class="line">sstr&gt;&gt;cname; </span><br><span class="line">cout&lt;&lt;cname; </span><br><span class="line">system(&quot;pause&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重复使用同一个stringstream进行数据转换时，必须调用其成员函数clear()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    int first, second;</span><br><span class="line">    stream&lt;&lt; &quot;456&quot;; &#x2F;&#x2F;插入字符串</span><br><span class="line">    stream &gt;&gt; first; &#x2F;&#x2F;转换成int</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; std::endl;</span><br><span class="line">    stream.clear(); &#x2F;&#x2F;在进行多次转换前，必须清除stream</span><br><span class="line">    stream &lt;&lt; true; &#x2F;&#x2F;插入bool值</span><br><span class="line">    stream &gt;&gt; second; &#x2F;&#x2F;提取出int</span><br><span class="line">    std::cout &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>stringstream有两种构造函数，一种是没有任何参数；另一种是带有参数。带有参数时，其参数将直接成为构造的stringstream对象的内容。另外，stringstream类还有一个成员函数put()。用于向stringstream中添加内容。当使用没有参数的方法构造stringstream时，使用put()函数则直接向stringstream尾部添加。使用带参数的方式时，使用put()函数就会从覆盖之前的内容。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;sstream&gt; </span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">string cc &#x3D; &quot;ccc&quot;;</span><br><span class="line">stringstream ostr;</span><br><span class="line">ostr &lt;&lt; cc;</span><br><span class="line">ostr.put(&#39;d&#39;); </span><br><span class="line">ostr.put(&#39;e&#39;); </span><br><span class="line">ostr&lt;&lt;&quot;fg&quot;; </span><br><span class="line">string gstr &#x3D; ostr.str(); </span><br><span class="line">cout&lt;&lt;gstr&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">char a; </span><br><span class="line">ostr&gt;&gt;a; </span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;cccdefg</span><br><span class="line">&#x2F;&#x2F;c</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;sstream&gt; </span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">stringstream ostr(&quot;ccc&quot;);</span><br><span class="line">ostr.put(&#39;d&#39;); </span><br><span class="line">ostr.put(&#39;e&#39;); </span><br><span class="line">ostr&lt;&lt;&quot;fg&quot;; </span><br><span class="line">string gstr &#x3D; ostr.str(); </span><br><span class="line">cout&lt;&lt;gstr&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">char a; </span><br><span class="line">ostr&gt;&gt;a; </span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;defg</span><br><span class="line">&#x2F;&#x2F;d</span><br></pre></td></tr></table></figure></li>
<li>广度优先搜索模版<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void BFS(int s)&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        取出队首元素top;</span><br><span class="line">        访问队首元素top;&#x2F;&#x2F;（访问可以是任何操作，例如打印输出）</span><br><span class="line">        将队首元素出队;</span><br><span class="line">        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个BFS的例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*问题描述：给出一个m*n的矩阵，矩阵中的元素为0或1，称位置（x，y）与其上下左右</span><br><span class="line">四个位置是相邻的，如果矩阵中有若干个1是相邻的（不必两两相邻），那么称这些1构成一个块。求给定矩阵中块的个数</span><br><span class="line">*&#x2F; </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define LOCAL</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int matrix[maxn][maxn];</span><br><span class="line">bool inq[maxn][maxn];</span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool judge(int x, int y)&#123;</span><br><span class="line">	if(x&gt;&#x3D;n || x&lt;0 || y&gt;&#x3D;m || y&lt;0)</span><br><span class="line">		return false;</span><br><span class="line">	if(matrix[x][y] &#x3D;&#x3D; 0 || inq[x][y] &#x3D;&#x3D; true)</span><br><span class="line">		return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;bool inq[maxn][maxn] &#x3D; &#123;false&#125;;</span><br><span class="line">	#ifdef LOCAL</span><br><span class="line">	freopen(&quot;data.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	#endif</span><br><span class="line">	int i, j, k, newx, newy, cnt&#x3D;0;</span><br><span class="line">	Node node;</span><br><span class="line">	queue&lt;Node&gt; q;</span><br><span class="line">	int plusx[4] &#x3D; &#123;0, 0, 1, -1&#125;;</span><br><span class="line">	int plusy[4] &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cin.get();</span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		for(j&#x3D;0; j&lt;m; j++)&#123;</span><br><span class="line">			cin &gt;&gt; matrix[i][j];</span><br><span class="line">			cin.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		for(j&#x3D;0; j&lt;m; j++)&#123;</span><br><span class="line">			if(judge(i, j))&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				node.x &#x3D; i;</span><br><span class="line">				node.y &#x3D; j;</span><br><span class="line">				q.push(node);</span><br><span class="line">				while(!q.empty())&#123;</span><br><span class="line">					Node top &#x3D; q.front();</span><br><span class="line">					q.pop();</span><br><span class="line">					for(k&#x3D;0; k&lt;4; k++)&#123;</span><br><span class="line">						newx &#x3D; top.x + plusx[k];</span><br><span class="line">						newy &#x3D; top.y + plusy[k];</span><br><span class="line">						node.x &#x3D; newx;</span><br><span class="line">						node.y &#x3D; newy;</span><br><span class="line">						if(judge(newx, newy))&#123;</span><br><span class="line">							q.push(node);</span><br><span class="line">							inq[node.x][node.y] &#x3D; true;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个DFS的例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*问题描述：有n件物品，每件物品的重量为w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为v的包中，使得在选入背包的物品不超过容量的情况下，让背包中物品的总价值最大，求最大价值</span><br><span class="line">*&#x2F;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define LOCAL</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line"></span><br><span class="line">int n, v;</span><br><span class="line">int maxvalue &#x3D; 0;</span><br><span class="line">int w[maxn];</span><br><span class="line">int c[maxn];</span><br><span class="line">void DFS(int index, int sumw, int sumc)&#123;</span><br><span class="line">	if(index &#x3D;&#x3D; n)&#123;</span><br><span class="line">		if(sumw &lt;&#x3D; v &amp;&amp; sumc &gt; maxvalue)&#123;</span><br><span class="line">			maxvalue &#x3D; sumc;</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(index+1, sumw, sumc);</span><br><span class="line">	DFS(index+1, sumw+w[index], sumc+c[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	#ifdef LOCAL</span><br><span class="line">	freopen(&quot;data_DFS.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	#endif</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">	cin.get();</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; w[i];</span><br><span class="line">		cin.get();</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; c[i];</span><br><span class="line">		cin.get();</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(0, 0, 0);</span><br><span class="line">	cout &lt;&lt; maxvalue;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>fill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(vec.begin(), vec.end(), val); val为将要替换的值。需要头文件<algorithm></li>
<li>使用nullptr来代替NULL</li>
<li>关于new和malloc</li>
</ul>
</li>
<li>申请内存时的位置可能会不同</li>
<li>使用new时会对对象进行初始化，例如申请了一个结构体的空间，会对结构体中的变量进行初始化。如果结构体中有string变量，但是使用的是malloc的话，会因为没有给string进行初始化而bomb</li>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型</li>
<li>C++提供了new[]与delete[]来专门处理数组类型:<br>A * ptr = new A[10];//分配10个A对象<br>使用new[]分配的内存必须使用delete[]进行释放：<br>delete [] ptr<br>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</li>
<li>使用new申请的空间，使用delete进行释放</li>
<li>特别大的数组不要在函数里面开，有可能会栈溢出。可以定义成全局变量。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/30/CSP%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" data-id="ck6g3avj10000kziefdopfmnm"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSP/" rel="tag">CSP</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/01/30/%E6%A8%A1%E7%94%B5%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">Newer</strong>
        <div class="article-nav-title">
          
            模电复习笔记
          
        </div>
      </a>
    
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 知 昂 张</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/head.svg" alt="知 昂 张"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>