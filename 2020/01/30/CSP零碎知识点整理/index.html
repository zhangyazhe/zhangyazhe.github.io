<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="课程笔记, 算法, 随笔, git, linux, Qt, Java, Big Data">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    CSP零碎知识点整理 |
    
    Kyle&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Kyle's blog" type="application/atom+xml">
</head>

<body>
<main class="content">
  <section class="outer">
  

<article id="post-CSP零碎知识点整理" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CSP零碎知识点整理
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/01/30/CSP%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-01-30T03:54:35.000Z" itemprop="datePublished">2020-01-30</time>
</a>
        
      </div>
    

    
      




    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>摘要：</p>
<p>笔记里面主要记录的是刷题过程中遇到过得问题或者学习到的新知识，涵盖C语言、C++、算法等方面内容</p>
<a id="more"></a>

<ul>
<li><p>判断整数是奇数还是偶数时，可以让这个数与1进行按位与，即num&amp;1，如果结果为1，则num为奇数，否则为偶数</p>
</li>
<li><p>进行整数向浮点数的转换时，可以乘以1.0</p>
</li>
<li><p>C++ vector容器浅析 <a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a><br>删除指定元素可以这样做： 删除第二个元素 (vec[1])<br>vec.erase(vec.begin() + 1);</p>
</li>
<li><p>C++ list总结 <a href="https://www.cnblogs.com/loleina/p/5179677.html" target="_blank" rel="noopener">https://www.cnblogs.com/loleina/p/5179677.html</a></p>
</li>
<li><p>C++ set成员函数用法总结 <a href="https://blog.csdn.net/qq_34243930/article/details/81481929" target="_blank" rel="noopener">https://blog.csdn.net/qq_34243930/article/details/81481929</a><br>set中的元素可以是pair，排序时，先按照first排序，相同的话再按照second排序。元素为pair时，set的find函数就不太好用了，这时可以使用upper_bound函数或者lower_bound()函数，函数中的比较规则也是先看first再看second。lower_bound()函数返回的是第一个不小于给定元素key的位置，upper_bound() 函数返回的是第一个大于给定元素key的位置。<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set&lt;pair&lt;int, int&gt; &gt; st;</span><br><span class="line">set&lt;pair&lt;int, int&gt; &gt;::iterator st_it;</span><br><span class="line">st.insert(make_pair(2, 6));</span><br><span class="line">st.insert(make_pair(1, 5)); </span><br><span class="line">st.insert(make_pair(3, 7));       </span><br><span class="line">st.insert(make_pair(4, 8));</span><br><span class="line">cout &lt;&lt; &quot;遍历输出&quot; &lt;&lt; endl;</span><br><span class="line">for(st_it &#x3D; st.begin(); st_it !&#x3D; st.end(); st_it++)&#123;</span><br><span class="line">    cout &lt;&lt; st_it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">st_it &#x3D; st.lower_bound(make_pair(3, 7));</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; &quot;查找输出&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; st_it-&gt;second;</span><br></pre></td></tr></table></figure></li>
<li><p>C++ map的基本操作和使用 <a href="https://blog.csdn.net/qq_40914533/article/details/81981467" target="_blank" rel="noopener">https://blog.csdn.net/qq_40914533/article/details/81981467</a></p>
</li>
<li><p>qsort()函数 <a href="https://www.runoob.com/cprogramming/c-function-qsort.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-function-qsort.html</a></p>
</li>
<li><p>C++ sort()函数 <a href="https://www.cnblogs.com/TX980502/p/8528840.html" target="_blank" rel="noopener">https://www.cnblogs.com/TX980502/p/8528840.html</a><br>sort和qsort之间更推荐sort<br>概述：需要头文件<algorithm><br>语法描述：sort（begin，end，cmp），cmp参数可以没有，如果没有默认非降序排序，end为最后一个元素再后面一个位置的指针<br>对于cmp函数的编写，如果return a&gt;b; 则理解为使用&gt;号对元素进行排序。<br>其实对于这么简单的任务（类型支持“&lt;”、“&gt;”等比较运算符），完全没必要自己写一个类出来。标准库里已经有现成的了，就在functional里，include进来就行了。functional提供了一堆基于模板的比较函数对象。它们是（看名字就知道意思了）：equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>。对于这个问题来说，greater和less就足够了，直接拿过来用：<br>升序：sort(begin,end,less<data-type>());<br>降序：sort(begin,end,greater<data-type>()).<br>详见文中：字符串内的字符排序、字符串之间排序、结构体的二级排序</p>
</li>
<li><p>C++ 运算符的重载 <a href="https://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-overloading.html</a></p>
</li>
<li><p>C++ 关系运算符的重载 <a href="https://www.runoob.com/cplusplus/relational-operators-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/relational-operators-overloading.html</a></p>
</li>
<li><p>C++ 优先队列priority_queue用法详解 <a href="https://blog.csdn.net/weixin_36888577/article/details/79937886" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36888577/article/details/79937886</a><br>优先队列中的内容默认是从大到小</p>
</li>
<li><p>一个函数实现16进制的数字与字符之间的转换：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;关键在于形参是char类型</span><br><span class="line">char getc(char c)&#123;   </span><br><span class="line">    if(c&lt;10)   </span><br><span class="line">        return c+&#39;0&#39;;   </span><br><span class="line">    else if(c&lt;&#x3D;16)   </span><br><span class="line">        return c+&#39;A&#39;-10;   </span><br><span class="line">    else if(c&lt;&#x3D;&#39;9&#39;)   </span><br><span class="line">        return c-&#39;0&#39;;   </span><br><span class="line">    else if(c&lt;&#x3D;&#39;F&#39;)   </span><br><span class="line">        return c-&#39;A&#39;+10;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对两个字符进行异或可以使用这个函数：ret=getc(getc(a[i])^getc(b[i]));先将字符转换为整数，进行异或之后再转换回字符</p>
</li>
<li><p>可以用宏来定义for循环，简化代码：#define UP(x) for(uint32_t i=0;i&lt;x;i++)   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UP(8)&#123;</span><br><span class="line">        a[i]&#x3D;getc(getc(a[i])^getc(b[i]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>C++ 引用：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br>引用很容易与指针混淆，它们之间有三个主要的不同：   </p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。   </li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。   </li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化</li>
</ul>
</li>
<li><p>C++  把引用作为返回值 <a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/returning-values-by-reference.html</a></p>
</li>
<li><p>C++ 把引用作为参数 <a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/passing-parameters-by-references.html</a></p>
<p>引用作为函数的形参时，函数的实参必须是变量，不能是常量</p>
</li>
<li><p>namespace以及using的用法 <a href="https://www.runoob.com/cplusplus/cpp-namespaces.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-namespaces.html</a></p>
</li>
<li><p>C++ cout：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::showpoint);  &#x2F;&#x2F; 设左对齐，以一般实数方式显示</span><br><span class="line">    cout.precision(5);       &#x2F;&#x2F; 设置除小数点外有五位有效数字 </span><br><span class="line">    cout&lt;&lt;123.456789&lt;&lt;endl;</span><br><span class="line">    cout.width(10);          &#x2F;&#x2F; 设置显示域宽10 </span><br><span class="line">    cout.fill(&#39;*&#39;);          &#x2F;&#x2F; 在显示区域空白处用*填充</span><br><span class="line">    cout&lt;&lt;resetiosflags(ios::left);  &#x2F;&#x2F; 清除状态左对齐</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::right);   &#x2F;&#x2F; 设置右对齐</span><br><span class="line">    cout&lt;&lt;123.456789&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::fixed);    &#x2F;&#x2F; 设左对齐，以固定小数位显示</span><br><span class="line">    cout.precision(3);    &#x2F;&#x2F; 设置实数显示三位小数</span><br><span class="line">    cout&lt;&lt;999.123456&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;resetiosflags(ios::left|ios::fixed);  &#x2F;&#x2F;清除状态左对齐和定点格式</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::scientific);    &#x2F;&#x2F;设置左对齐，以科学技术法显示 </span><br><span class="line">    cout.precision(3);   &#x2F;&#x2F;设置保留三位小数</span><br><span class="line">    cout&lt;&lt;123.45678&lt;&lt;endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123.46</span><br><span class="line">****123.46</span><br><span class="line">999.123</span><br><span class="line">1.235e+02</span><br></pre></td></tr></table></figure>
<p>setiosflags中的常见标志：<br>boolalpha    可以使用单词”true”和”false”进行输入/输出的布尔值.<br>oct    用八进制格式显示数值.<br>dec    用十进制格式显示数值.<br>hex    用十六进制格式显示数值.<br>left    输出调整为左对齐.<br>right    输出调整为右对齐.<br>scientific    用科学记数法显示浮点数.<br>fixed    用正常的记数方法显示浮点数(与科学计数法相对应).<br>showbase    输出时显示所有数值的基数.<br>showpoint    显示小数点和额外的零，即使不需要.<br>showpos    在非负数值前面显示”＋（正号）”.<br>skipws    当从一个流进行读取时，跳过空白字符(spaces, tabs, newlines).<br>unitbuf    在每次插入以后，清空缓冲区.<br>internal    将填充字符回到符号和数值之间.<br>uppercase    以大写的形式显示科学记数法中的”e”和十六进制格式的”x”.   </p>
</li>
<li><p>cout在输出时进行进制转换很方便。</p>
<p>hex为16进制，oct为8进制，dec为十进制。在修改格式之前，原来的格式将一直有效。输出hex时字母默认小写，cout &lt;&lt; hex &lt;&lt; uppercase可以输出大写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; oct &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; dec &lt;&lt; n;</span><br><span class="line">  	<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 2a 52 42 2A</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，被输出的值必须是int型。例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"[38m"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; <span class="string">"\\x"</span> &lt;&lt; (<span class="keyword">int</span>)c;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output : \x5B\x33\x38\x6D</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，如果没有将c转换成int型，输出的就还是[38m。</p>
</li>
<li><p><strong>C++</strong> 输入：</p>
<ul>
<li>cin<br>输入时，以空格、tab、回车作为分隔符。当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，<strong>cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&gt;&gt;不做处理</strong></li>
<li>cin.getline()<br>用于读取字符串，读到的字符串是c++风格的string类型。<br>cin.getline默认读取到回车时终止，并将回车符号转换为\0存入字符串，同时将回车符从缓冲区中删除。空格也会被读取<br>函数原型有两个：   </li>
</ul>
</li>
</ul>
<p><em>//s是存放读取到的字符串的数组，count是读取长度<br>istream&amp; getline(char</em> s, streamsize count); //默认以换行符结束<br>istream&amp; getline(char* s, streamsize count, char delim);//delim为规定的结束符*   </p>
<ul>
<li><p>getline()<br>getline(cin, str)与cin.getline(str, num)作用相同，都可以读取空格，默认以回车结束。但是cin.getline的str要求是字符数组，且必须要指定num。而getline的str是string类型的变量，而且不需要指定长度。所以推荐使用getline。</p>
</li>
<li><p>cin.get<br>使用cin.get读取字符串时，可以这样使用：<br>ch = cin.get();<br>cin.get(ch);<br>或者直接cin.get()表示不将输入读取到任何变量，只是用来阻塞或者清除多余回车<br>cin.get()也可以用于读取字符串，不建议使用</p>
</li>
<li><p>gets<br>不建议使用</p>
</li>
<li><p>综上所述，普通输入用cin，读取字符串用getline()，读取字符用cin.get()</p>
<ul>
<li>ios::sync_with_stdio(false)可以用来提高cin和cout的速度。cin.tie(0);cout.tie(0);也可以加速io</li>
<li>C++ 字符串<br>Cpp提供了两种类型的字符串表示形式：一种是C风格的字符串，另一种是C++风格的string类型字符串 </li>
<li>头文件<string><cstring>之间的区别：cstring是c语言中的string.h的c++版本，用法相同，用于处理C语言形式的字符串。引用string后就可以使用string类型（其实不引用也可以使用string类型），同时可以使用下面的string类中的函数。在处理字符串时，需要注意C++与c类型的字符串之间的区别，平时尽量只使用c++类型的字符串，必要时可以使用string类中的data()或者c_str()函数将string类型的字符串转化为c类型的字符串，两种方法的不同之处是，c_str()转换后会在最后加\0，而data()不会。</li>
<li>c_str()应该这样用: char c[20]; string s=”1234”; strcpy(c,s.c_str()); 这样才不会出错,c_str()返回的是一个临时指针,不能对其进行操作</li>
<li>C++ string类   </li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/Draymonder/p/6944479.html" target="_blank" rel="noopener">https://www.cnblogs.com/Draymonder/p/6944479.html</a></p>
</li>
<li><p>构造函数(Constructors)<br>语法:<br>string();<br>string( size_type length, char ch );<br>string( const char *str );参数是c形式字符串，可以实现c形式字符串到c++形式字符串的转换<br>string( const char *str, size_type length );<br>string( string &amp;str, size_type index, size_type length );<br>string( input_iterator start, input_iterator end );<br>字符串的构造函数创建一个新字符串，包括:<br>以length为长度的ch的拷贝（即length个ch）<br>以str为初值 (长度任意),<br>以index为索引开始的子串，长度为length, 或者<br>以从start到end的元素为初值.<br>例如,<br>string str1( 5, ‘c’ );<br>string str2( “Now is the time…” );<br>string str3( str2, 11, 4 );<br>cout &lt;&lt; str1 &lt;&lt; endl;<br>cout &lt;&lt; str2 &lt;&lt; endl;<br>cout &lt;&lt; str3 &lt;&lt; endl;<br>显示<br>ccccc<br>Now is the time…<br>time   </p>
</li>
<li><p>对字符串赋值方法很多，例如：<br>string s1(“hello”), s2;<br>s2 = s1;<br>或者用assign函数s2.assign(s1)</p>
</li>
<li><p>求字符串长度可以用.length()也可以用.size()</p>
</li>
<li><p>除了使用+、+=来连接字符串之外，还可以用append()函数在字符串末尾添加内容</p>
</li>
<li><p>字符串比较可以使用&gt; &lt; &gt;= &lt;=等等，比较的不是字符串长度，而是一位一位地比较字母的大小。</p>
<ul>
<li>201709_2：需要进行多重排序时，可以将排序依据包装到一个结构体里面，然后编写cmp函数，利用sort函数进行排序</li>
<li>什么是标准模板库（STL）？<br>(1)C++标准模板库与C++标准库的关系<br>C++标准模板库其实属于C++标准库的一部分，C++标准模板库主要是定义了标准模板的定义与声明，而这些模板主要都是<br>类模板，我们可以调用这些模板来定义一个具体的类；与之前的自己手动创建一个函数模版或者是类模板不一样，我们使用了<br>STL就不用自己来创建模板了，这些模板都定义在标准模板库中，我们只需要学会怎么使用这些类模板来定义一个具体的类，<br>然后能够使用类提供的各种方法来处理数据。<br>(2)STL六大组件：容器（containers）、算法（algorithms）、迭代器（iterators）、函数对象（functors）、适配器（adapters）、分配器（allocators）</li>
<li>在C++中，结构体可以有构造函数。例如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct ROLE&#123;</span><br><span class="line">    int health;</span><br><span class="line">    int attack;</span><br><span class="line">    ROLE()&#123;health &#x3D; 0; attack &#x3D; -1;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int r,c,dist;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(int r,int c,int dist):r(r),c(c),dist(dist)&#123;&#125;&#x2F;&#x2F;r(r)表示将r赋值给变量r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在C++中，定义结构体时不需要使用typedef，创建一个新的结构体变量的时候也不需要再加上struct，直接使用结构体的名字即可。例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123; &#x2F;&#x2F; 声明结构体</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a_st;  &#x2F;&#x2F;定义结构体</span><br><span class="line">A* a_p; &#x2F;&#x2F; 定义结构体指针</span><br></pre></td></tr></table></figure></li>
<li>使用#ifdef提高效率，例如<br>int main()<br>{<br>#ifdef LOCAL<br>freopen(“datain.txt”,”r”,stdin);<br>#endif // LOCAL<br>run();<br>ans();<br>return 0;<br>}<br>如果在前面已经有#define LOCAL，那么就会执行freopen，否则就直接执行endif后面的语句。在本地测试时，要在前面加上#define LOCAL，这样只需要将测试用例写到datain.txt中，不需要每次都手动输入。提交时，将#define LOCAL删除。</li>
<li>使用stringstream进行数据转换（int-&gt;string）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    std::string result;</span><br><span class="line">    int i &#x3D; 1000;</span><br><span class="line">    stream &lt;&lt; i; &#x2F;&#x2F;将int输入流</span><br><span class="line">    stream &gt;&gt; result; &#x2F;&#x2F;从stream中抽取前面插入的int值</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; &#x2F;&#x2F; print the string &quot;1000&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stringstream进行数据类型转换(int-&gt;char*)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    char result[8] ;</span><br><span class="line">    stream &lt;&lt; 8888; &#x2F;&#x2F;向stream中插入8888</span><br><span class="line">    stream &gt;&gt; result; &#x2F;&#x2F;抽取stream中的值到result</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; &#x2F;&#x2F; 屏幕显示 &quot;8888&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stringstream进行数据类型转换()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">＃i nclude &lt;iostream&gt; </span><br><span class="line">＃i nclude &lt;sstream&gt; </span><br><span class="line">＃i nclude &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">stringstream sstr; </span><br><span class="line">string name &#x3D; &quot;colinguan&quot;; </span><br><span class="line">char cname[200]; </span><br><span class="line">sstr&lt;&lt;name; </span><br><span class="line">sstr&gt;&gt;cname; </span><br><span class="line">cout&lt;&lt;cname; </span><br><span class="line">system(&quot;pause&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用ss拼接字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="string">"string,"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">" second string"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strResult is: "</span> &lt;&lt; sstream.str() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//注意这里str()的用法，使用str()可得到ss中的字符串</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 清空 sstream</span></span><br><span class="line">    sstream.str(<span class="string">""</span>);</span><br><span class="line">    sstream &lt;&lt; <span class="string">"third string"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After clear, strResult is: "</span> &lt;&lt; sstream.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>重复使用同一个stringstream进行数据转换时，必须调用其成员函数clear()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> stream;</span><br><span class="line">    <span class="keyword">int</span> first, second;</span><br><span class="line">    stream&lt;&lt; <span class="string">"456"</span>; <span class="comment">//插入字符串</span></span><br><span class="line">    stream &gt;&gt; first; <span class="comment">//转换成int</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    stream.clear(); <span class="comment">//在进行多次转换前，必须清除stream</span></span><br><span class="line">    stream &lt;&lt; <span class="literal">true</span>; <span class="comment">//插入bool值</span></span><br><span class="line">    stream &gt;&gt; second; <span class="comment">//提取出int</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关于stringstream的清空，其实有两种方式，第一种是ss.clear()，第二种是ss.str(“”)。他们的使用场景不同，每次在使用ss进行类型转换前，必须使用clear进行清空，如果不使用clear或者使用str(“”)都会导致出错。而如果只是使用ss进行字符串的操作，例如字符串的拼接，就使用str(“”)进行清空。</p>
</li>
<li><p>stringstream有两种构造函数，一种是没有任何参数；另一种是带有参数。带有参数时，其参数将直接成为构造的stringstream对象的内容。另外，stringstream类还有一个成员函数put()。用于向stringstream中添加内容。当使用没有参数的方法构造stringstream时，使用put()函数则直接向stringstream尾部添加。使用带参数的方式时，使用put()函数就会从覆盖之前的内容。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">string</span> cc = <span class="string">"ccc"</span>;</span><br><span class="line"><span class="built_in">stringstream</span> ostr;</span><br><span class="line">ostr &lt;&lt; cc;</span><br><span class="line">ostr.put(<span class="string">'d'</span>); </span><br><span class="line">ostr.put(<span class="string">'e'</span>); </span><br><span class="line">ostr&lt;&lt;<span class="string">"fg"</span>; </span><br><span class="line"><span class="built_in">string</span> gstr = ostr.str(); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;gstr&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a; </span><br><span class="line">ostr&gt;&gt;a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">//cccdefg</span></span><br><span class="line"><span class="comment">//c</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ostr</span><span class="params">(<span class="string">"ccc"</span>)</span></span>;</span><br><span class="line">ostr.put(<span class="string">'d'</span>); </span><br><span class="line">ostr.put(<span class="string">'e'</span>); </span><br><span class="line">ostr&lt;&lt;<span class="string">"fg"</span>; </span><br><span class="line"><span class="built_in">string</span> gstr = ostr.str(); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;gstr&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a; </span><br><span class="line">ostr&gt;&gt;a; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">//defg</span></span><br><span class="line"><span class="comment">//d</span></span><br></pre></td></tr></table></figure></li>
<li><p>stringstream默认空格直接分词</p>
<p>題目：输入的第一行有一个数字 N 代表接下來有 N 行数字，每一行数字里有不固定个数的整数，打印每一行的总和。</p>
<p>输入：</p>
<p>3<br>1 2 3<br>20 17 23 54 77 60<br>111 222 333 444 555 666 777 888 999</p>
<p>输出：</p>
<p>6<br>251<br>4995</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="keyword">int</span> n, i, sum, a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">getline(<span class="built_in">cin</span>, s); <span class="comment">// 换行读取</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line">ss.clear();</span><br><span class="line">ss.str(s);</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ss &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> ( ss.fail() )   <span class="keyword">break</span>;</span><br><span class="line">sum+=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ss已经空了但还要执行将其中的内容往外取的话，就会得到ss.fail()</p>
</li>
<li><p>stringstream利用指定字符分割字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> data = <span class="string">"1_2_3_4_5_6"</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> item;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::getline(ss, item, <span class="string">'_'</span>)) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1_2_3_4_5_6</span></span><br><span class="line"><span class="comment">//1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用stringstream可以将string一位一位地输出到char中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> a = <span class="string">"aa+bb+cc+dd"</span>;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(a)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ss &gt;&gt; c) &#123;</span><br><span class="line">	    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//+</span></span><br><span class="line"><span class="comment">//后面的省略</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>广度优先搜索模版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void BFS(int s)&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        取出队首元素top;</span><br><span class="line">        访问队首元素top;&#x2F;&#x2F;（访问可以是任何操作，例如打印输出）</span><br><span class="line">        将队首元素出队;</span><br><span class="line">        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个BFS的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*问题描述：给出一个m*n的矩阵，矩阵中的元素为0或1，称位置（x，y）与其上下左右</span><br><span class="line">四个位置是相邻的，如果矩阵中有若干个1是相邻的（不必两两相邻），那么称这些1构成一个块。求给定矩阵中块的个数</span><br><span class="line">*&#x2F; </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define LOCAL</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int matrix[maxn][maxn];</span><br><span class="line">bool inq[maxn][maxn];</span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool judge(int x, int y)&#123;</span><br><span class="line">	if(x&gt;&#x3D;n || x&lt;0 || y&gt;&#x3D;m || y&lt;0)</span><br><span class="line">		return false;</span><br><span class="line">	if(matrix[x][y] &#x3D;&#x3D; 0 || inq[x][y] &#x3D;&#x3D; true)</span><br><span class="line">		return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;bool inq[maxn][maxn] &#x3D; &#123;false&#125;;</span><br><span class="line">	#ifdef LOCAL</span><br><span class="line">	freopen(&quot;data.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	#endif</span><br><span class="line">	int i, j, k, newx, newy, cnt&#x3D;0;</span><br><span class="line">	Node node;</span><br><span class="line">	queue&lt;Node&gt; q;</span><br><span class="line">	int plusx[4] &#x3D; &#123;0, 0, 1, -1&#125;;</span><br><span class="line">	int plusy[4] &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cin.get();</span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		for(j&#x3D;0; j&lt;m; j++)&#123;</span><br><span class="line">			cin &gt;&gt; matrix[i][j];</span><br><span class="line">			cin.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		for(j&#x3D;0; j&lt;m; j++)&#123;</span><br><span class="line">			if(judge(i, j))&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				node.x &#x3D; i;</span><br><span class="line">				node.y &#x3D; j;</span><br><span class="line">				q.push(node);</span><br><span class="line">				while(!q.empty())&#123;</span><br><span class="line">					Node top &#x3D; q.front();</span><br><span class="line">					q.pop();</span><br><span class="line">					for(k&#x3D;0; k&lt;4; k++)&#123;</span><br><span class="line">						newx &#x3D; top.x + plusx[k];</span><br><span class="line">						newy &#x3D; top.y + plusy[k];</span><br><span class="line">						node.x &#x3D; newx;</span><br><span class="line">						node.y &#x3D; newy;</span><br><span class="line">						if(judge(newx, newy))&#123;</span><br><span class="line">							q.push(node);</span><br><span class="line">							inq[node.x][node.y] &#x3D; true;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个DFS的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*问题描述：有n件物品，每件物品的重量为w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为v的包中，使得在选入背包的物品不超过容量的情况下，让背包中物品的总价值最大，求最大价值</span><br><span class="line">*&#x2F;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define LOCAL</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line"></span><br><span class="line">int n, v;</span><br><span class="line">int maxvalue &#x3D; 0;</span><br><span class="line">int w[maxn];</span><br><span class="line">int c[maxn];</span><br><span class="line">void DFS(int index, int sumw, int sumc)&#123;</span><br><span class="line">	if(index &#x3D;&#x3D; n)&#123;</span><br><span class="line">		if(sumw &lt;&#x3D; v &amp;&amp; sumc &gt; maxvalue)&#123;</span><br><span class="line">			maxvalue &#x3D; sumc;</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(index+1, sumw, sumc);</span><br><span class="line">	DFS(index+1, sumw+w[index], sumc+c[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	#ifdef LOCAL</span><br><span class="line">	freopen(&quot;data_DFS.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	#endif</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">	cin.get();</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; w[i];</span><br><span class="line">		cin.get();</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; c[i];</span><br><span class="line">		cin.get();</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(0, 0, 0);</span><br><span class="line">	cout &lt;&lt; maxvalue;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用DFS解决问题时，可以有递归和非递归两种方式来实现DFS，非递归版本借助栈来实现，与BFS类似。对于上面的背包问题，我们只能使用递归版本的DFS。而对于一些图相关的问题，我们可以使用非递归的dfs.</p>
</li>
<li><p>fill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(vec.begin(), vec.end(), val); val为将要替换的值。需要头文件<algorithm></p>
</li>
<li><p>使用nullptr来代替NULL</p>
</li>
<li><p>关于new和malloc</p>
<ul>
<li>申请内存时的位置可能会不同</li>
<li>使用new时会对对象进行初始化，例如申请了一个结构体的空间，会对结构体中的变量进行初始化。如果结构体中有string变量，但是使用的是malloc的话，会因为没有给string进行初始化而bomb</li>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型</li>
<li>C++提供了new[]与delete[]来专门处理数组类型:<br>A * ptr = new A[10];//分配10个A对象<br>使用new[]分配的内存必须使用delete[]进行释放：<br>delete [] ptr<br>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</li>
<li>使用new申请的空间，使用delete进行释放</li>
<li>特别大的数组不要在函数里面开，有可能会栈溢出。可以定义成全局变量。</li>
</ul>
</li>
<li><p>tarjan算法</p>
<p>tarjan算法用来求图中的强连通分量。tarjan算法是基于DFS算法的，会给每个访问的节点一个时间戳，时间戳存在DFN[]数组里面，同时还要记录每个节点的能回溯到的最早访问的节点的时间戳，这些存在low[]数组中。当访问到某一个节点i，有DFN[i] == low[i]时，便找到了一个新的强连通分量。</p>
<p>tarjan算法模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5010<span class="comment">//题目中可能的最大点数</span></span></span><br><span class="line"><span class="keyword">int</span> STACK[M],top=<span class="number">0</span>;<span class="comment">//Tarjan算法中的栈</span></span><br><span class="line"><span class="keyword">bool</span> InStack[M];<span class="comment">//检查是否在栈中</span></span><br><span class="line"><span class="keyword">int</span> DFN[M] = &#123;<span class="number">0</span>&#125;;<span class="comment">//深度优先搜索访问次序</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Low[M];<span class="comment">//能追溯到的最早的次序</span></span><br><span class="line"><span class="keyword">int</span> ComponentNumber=<span class="number">0</span>;<span class="comment">//有向图强连通分量个数</span></span><br><span class="line"><span class="keyword">int</span> Index=<span class="number">0</span>;<span class="comment">//索引号</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Edge[M];<span class="comment">//邻接表表示</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Component[M];<span class="comment">//获得强连通分量结果</span></span><br><span class="line"><span class="keyword">int</span> InComponent[M];<span class="comment">//记录每个点在第几号强连通分量里</span></span><br><span class="line"><span class="keyword">int</span> ComponentDegree[M];<span class="comment">//记录每个强连通分量的度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    DFN[i]=Low[i]=++Index;</span><br><span class="line">    InStack[i]=<span class="literal">true</span>;STACK[++top]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e=<span class="number">0</span>;e&lt;Edge[i].size();e++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=Edge[i][e];</span><br><span class="line">        <span class="keyword">if</span> (DFN[j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(j);</span><br><span class="line">            Low[i]=min(Low[i],Low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (InStack[j]) Low[i]=min(Low[i],DFN[j]);<span class="comment">//也可Low[i]=min(Low[i],Low[j]);仅限在求强联通分量时</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DFN[i]==Low[i])</span><br><span class="line">    &#123;</span><br><span class="line">        ComponentNumber++;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            j=STACK[top--];</span><br><span class="line">            InStack[j]=<span class="literal">false</span>;</span><br><span class="line">            Component[ComponentNumber].push_back(j);</span><br><span class="line">            InComponent[j]=ComponentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j!=i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>string.size()返回的是unsigned类型的变量，如果要执行减一操作的话，一定要先转换成int类型，否则就会得到一个巨大的数</p>
</li>
<li><p>快速排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序（从小到大）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> i, j, base, temp;</span><br><span class="line">	i = left, j = right;</span><br><span class="line">	base = arr[left];  <span class="comment">//取最左边的数为基准数</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (arr[j] &gt;= base &amp;&amp; i &lt; j)</span><br><span class="line">			j--;</span><br><span class="line">		<span class="keyword">while</span> (arr[i] &lt;= base &amp;&amp; i &lt; j)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = arr[i];</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			arr[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//基准数归位</span></span><br><span class="line">	arr[left] = arr[i];</span><br><span class="line">	arr[i] = base;</span><br><span class="line">	quickSort(left, i - <span class="number">1</span>, arr);<span class="comment">//递归左边</span></span><br><span class="line">	quickSort(i + <span class="number">1</span>, right, arr);<span class="comment">//递归右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当需要用map但是又不需要让内容有序时，可以使用unordered_map查询效率更高。需要头文件<unordered_map></p>
</li>
<li><p>map在插入新的元素时，可以使用下标的方式，即mp[i]，这种方式插入时，如果下标相同，会直接覆盖。另外还可以使用mp.insert(make_pair(1,2))的方式进行插入，这个时候如果插入了相同的key，会直接报错</p>
</li>
<li><p>创建map时，使用map&lt;int, int, greater<int> &gt; mp即可使得mp中的元素按照key值降序排序</p>
</li>
<li><p>使用map时，即使没有对map[x]赋值，还是可以直接使用map[x]，其值为0</p>
</li>
<li><p>注意数据溢出的问题，必要时候使用long long</p>
</li>
<li><p>multimap</p>
<ul>
<li><p>multimap中的键值对的key值可以相同，其中的数据依然是按照key值有序的</p>
</li>
<li><p>使用insert插入元素时总是成功，但是multimap不支持通过下标的方式插入，因为通过键不能确定唯一的元素</p>
</li>
<li><p>一般来说，我们想访问给定键对应的所有元素。成员函数 equal_range() 就可以做到这一点。它会返回一个封装了两个迭代器的 pair 对象，这两个迭代器所确定范围内的元素的键和参数值相等。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pr = people.equal_range(<span class="string">"Ann"</span>);</span><br><span class="line"><span class="keyword">if</span>(pr.first != <span class="built_in">std</span>::end(people))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pr.first ; iter != pr.second; ++iter)</span><br><span class="line">        <span class="built_in">std</span>:<span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" is "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>vector find</p>
<ul>
<li><p>不同于map（map有find方法），vector本身是没有find这一方法，其find是依靠algorithm来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"> </span><br><span class="line">    vec.push_back(<span class="number">1</span>);</span><br><span class="line">    vec.push_back(<span class="number">2</span>);</span><br><span class="line">    vec.push_back(<span class="number">3</span>);</span><br><span class="line">    vec.push_back(<span class="number">4</span>);</span><br><span class="line">    vec.push_back(<span class="number">5</span>);</span><br><span class="line">    vec.push_back(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(vec.begin(), vec.end(), <span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (it != vec.end())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"can not find"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<ul>
<li><p>在函数里面开数组的话，使用的是栈空间，大概只有2M。如果定义全局数组，使用的是静态区，大概有2G。所以如果要开一个比较大的数组，最好定义成全局变量。如果数组的大小达到了10的9次方，最好换一个思路。</p>
</li>
<li><p>万能头文件&lt;bits/stdc++.h&gt;</p>
</li>
<li><p>使用语句std::ios::sync_with_stdio(false)后，可以提高cin和cout的速度，但是加了这个语句之后就不要再使用scanf和printf了，另外这句话最好加载freopen之后</p>
</li>
<li><p>count函数与count_if函数</p>
<ul>
<li><p>count函数例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//count函数的用法</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	v[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	v[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">	v[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">	v[<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">	v[<span class="number">6</span>] = <span class="number">6</span>;</span><br><span class="line">	v[<span class="number">7</span>] = <span class="number">7</span>;</span><br><span class="line">	v[<span class="number">8</span>] = <span class="number">8</span>;</span><br><span class="line">	v[<span class="number">9</span>] = <span class="number">9</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//向量计数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count(v.begin(), v.end(), <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count(v.begin(), v.end(), <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count(v.begin(), v.end(), <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//数组计数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count(a, a + <span class="number">10</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count(a, a + <span class="number">10</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count(a, a + <span class="number">10</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>count_if函数例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        V.push_back(i);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count_if(V.begin(),V.end(),comp)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/30/CSP%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" data-id="ckezltsxz0009gzt32yta6mt5"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/01/30/%E6%A8%A1%E7%94%B5%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">Newer</strong>
        <div class="article-nav-title">
          
            模电复习笔记
          
        </div>
      </a>
    
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

  
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>

  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '77424c281e336f5d09b3',
      clientSecret: '7d8c854fef95db82c20d7e4820001abd45995754',
      repo: 'zyz_talk',
      owner: 'zhangyazhe',
      admin: ['zhangyazhe'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

    
  <div class="gitalk" id="gitalk-container"></div>
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

  
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>

  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '77424c281e336f5d09b3',
      clientSecret: '7d8c854fef95db82c20d7e4820001abd45995754',
      repo: 'zyz_talk',
      owner: 'zhangyazhe',
      admin: ['zhangyazhe'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Kyle&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/head.svg" alt="Kyle&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>