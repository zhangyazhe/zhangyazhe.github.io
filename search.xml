<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Big Data Note</title>
    <url>/2020/03/21/Big-Data-Note/</url>
    <content><![CDATA[<p>摘要：</p>
<p>hadoop、Kafka、Flink</p>
<p>持续更新中</p>
<a id="more"></a>

<h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><ul>
<li><p>hadoop两大核心组件：HDFS和MapReduce</p>
</li>
<li><p>MapReduce两大核心组件：JobTracker和TaskTraker</p>
<p>前者对整个作业任务进行管理，会把用户的大作业拆分成很多的小作业，每一个小作业在一个机器上执行，这个机器上的小作业就由部署在该机器的TaskTraker进行追踪和执行。</p>
</li>
<li><p>DataNode和TaskTraker可以部署在同一台机器上</p>
</li>
</ul>
<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><ul>
<li><p>块的概念：与普通文件系统中块的概念类似，但是HDFS中的块会大很多。如果块太小的话，块的数量就会很多，后续的寻址开销就会很大。通过块的设计，将一个大文件拆分成若干的块，如此便可以存储在不同的机器上。每个块的大小是固定的，也方便对数据进行管理。</p>
</li>
<li><p>HDFS中的NamaNode和DataNode</p>
<ul>
<li><p>NameNode用来记录文件的每一个部分都被存储在了哪台机器上面，DataNode用来实际存储数据。NameNode中存储的是元数据，元数据记录了文件是什么、文件被分成多少块、每个块和文件是怎么映射的、每个块被存储到那个服务器上面等等信息。</p>
</li>
<li><p>元数据有两个关键的数据结构：FsImage和Editlog。</p>
<p>FsImage用来保存系统文件树以及文件树中所有的文件和文件夹中的元数据。其中包括文件的复制等级、修改和访问时间、访问权限、块大小以及组成文件的块。但是，每个块具体没存储在哪个节点的信息不是由FsImage保存的。</p>
<p>EditLog用来记录对数据进行的操作。</p>
<p>在NameNode工作起来的时候，FsImage中的存的是历史数据，而EditLog中存的是对历史数据所有的操作。首先需要根据F中的历史数据以及E中记录的操作，得到最新的元数据信息。NameNode会把最新元数据的F保存下来，然后把旧版的删掉，同时再创建一个新的空的E。之后，在对数据进行操作的时候，因为F比较大，如果每次都去操作F的话，效率很低。所以我们只是将更新的操作存到E里面。</p>
</li>
<li><p>在NN（NameNode）工作过程中，E会不断变大。这时候，每间隔一段时间，SecondaryNameNode（第二名称节点）会让主N停止向E中写东西，同时将主N的F和E都通过HTTP的方式下载过来。在这个过程中，主N会将新的操作记录在edit.new中。第二N会根据F和E合并出新的F，再将新的F发给主N。然后主N会将edit.new更改成新的E。这样就既解决了E不断变大的问题，同时实现了第二N的冷备份。</p>
</li>
</ul>
</li>
<li><p>HDFS存储原理</p>
<p>通常来讲，所有的数据块都会被存放3份，也就是冗余数据，用来保证一个数据出问题后，还可以恢复。三个块不会存储在同一个节点内。对于第一个块，如果这个块是某一个集群内部的某一个节点产生的，那么就会吧这个快存放在这个节点上。如果这个块是外部产生的，HDFS会选一个比较空闲的节点来存放数据；对于第二个块，会放在不同机架上的某一个节点。对于第三个块，会放在和第一个节点相同的机架上面的不同节点上面。（集群中有很多机架，每个机架上有很多节点，同一机架的节点之间的数据传输带宽是很高的）</p>
</li>
<li><p>HDFS读取原理</p>
<p>读取时，理论上可以从之前存储的任意一个冗余的块中进行读取。但是一般会采取就近原则。HDFS提供一个API，可以算出数据所在的机架UD，也算出需要读取数据的节点的机架ID，这样就可以选一个比较近的进行读取。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201509_4 高速公路</title>
    <url>/2020/03/21/csp-201509-4-%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF/</url>
    <content><![CDATA[<p>摘要：</p>
<p>tarjan算法</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>某国有<em>n</em>个城市，为了使得城市间的交通更便利，该国国王打算在城市之间修一些高速公路，由于经费限制，国王打算第一阶段先在部分城市之间修一些单向的高速公路。</p>
<p>现在，大臣们帮国王拟了一个修高速公路的计划。看了计划后，国王发现，有些城市之间可以通过高速公路直接（不经过其他城市）或间接（经过一个或多个其他城市）到达，而有的却不能。如果城市A可以通过高速公路到达城市B，而且城市B也可以通过高速公路到达城市A，则这两个城市被称为便利城市对。</p>
<p>国王想知道，在大臣们给他的计划中，有多少个便利城市对。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示城市和单向高速公路的数量。</p>
<p>接下来<em>m</em>行，每行两个整数<em>a</em>, <em>b</em>，表示城市<em>a</em>有一条单向的高速公路连向城市<em>b</em>。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包含一个整数，表示便利城市对的数量。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5 5<br>1 2<br>2 3<br>3 4<br>4 2<br>3 5</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>3</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>前30%的评测用例满足1 ≤ <em>n</em> ≤ 100, 1 ≤ <em>m</em> ≤ 1000；</p>
<p>前60%的评测用例满足1 ≤ <em>n</em> ≤ 1000, 1 ≤ <em>m</em> ≤ 10000；</p>
<p>所有评测用例满足1 ≤ <em>n</em> ≤ 10000, 1 ≤ <em>m</em> ≤ 100000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始我用的方法是BFS，把每个节点的可达性信息统计出来，然后再去找他们中间彼此均可达的节点对。这种方法虽然可以得到正确结果，但是内存会爆。上网查了之后发现还是要用tarjan算法，找出图中的强连通分量。u1s1算法原理只懂了个大概，tarjan算法是基于DFS算法的，会给每个访问的节点一个时间戳，时间戳存在DFN[]数组里面，同时还要记录每个节点的能回溯到的最早访问的节点的时间戳，这些存在low[]数组中。当访问到某一个节点i，有DFN[i] == low[i]时，便找到了一个新的强连通分量。</p>
<p>tarjan算法模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5010<span class="comment">//题目中可能的最大点数</span></span></span><br><span class="line"><span class="keyword">int</span> STACK[M],top=<span class="number">0</span>;<span class="comment">//Tarjan算法中的栈</span></span><br><span class="line"><span class="keyword">bool</span> InStack[M];<span class="comment">//检查是否在栈中</span></span><br><span class="line"><span class="keyword">int</span> DFN[M] = &#123;<span class="number">0</span>&#125;;<span class="comment">//深度优先搜索访问次序</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Low[M];<span class="comment">//能追溯到的最早的次序</span></span><br><span class="line"><span class="keyword">int</span> ComponentNumber=<span class="number">0</span>;<span class="comment">//有向图强连通分量个数</span></span><br><span class="line"><span class="keyword">int</span> Index=<span class="number">0</span>;<span class="comment">//索引号</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Edge[M];<span class="comment">//邻接表表示</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Component[M];<span class="comment">//获得强连通分量结果</span></span><br><span class="line"><span class="keyword">int</span> InComponent[M];<span class="comment">//记录每个点在第几号强连通分量里</span></span><br><span class="line"><span class="keyword">int</span> ComponentDegree[M];<span class="comment">//记录每个强连通分量的度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    DFN[i]=Low[i]=++Index;</span><br><span class="line">    InStack[i]=<span class="literal">true</span>;STACK[++top]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e=<span class="number">0</span>;e&lt;Edge[i].size();e++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=Edge[i][e];</span><br><span class="line">        <span class="keyword">if</span> (DFN[j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(j);</span><br><span class="line">            Low[i]=min(Low[i],Low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (InStack[j]) Low[i]=min(Low[i],DFN[j]);<span class="comment">//也可Low[i]=min(Low[i],Low[j]);仅限在求强联通分量时</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DFN[i]==Low[i])</span><br><span class="line">    &#123;</span><br><span class="line">        ComponentNumber++;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            j=STACK[top--];</span><br><span class="line">            InStack[j]=<span class="literal">false</span>;</span><br><span class="line">            Component[ComponentNumber].push_back(j);</span><br><span class="line">            InComponent[j]=ComponentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j!=i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">10005</span>],low[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">10005</span>],ins[<span class="number">10005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;E[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> sum,tot;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[v]=low[v]=++tot;</span><br><span class="line">	s.push(v);</span><br><span class="line">	ins[v]=<span class="number">1</span>;</span><br><span class="line">	vis[v]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E[v].size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> vv=E[v][i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[vv])&#123;</span><br><span class="line">			tarjan(vv);</span><br><span class="line">			low[v]=min(low[v],low[vv]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ins[vv])</span><br><span class="line">		&#123;</span><br><span class="line">			low[v]=min(low[v],dfn[vv]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[v]==low[v])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> now=s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">			ins[now]=<span class="number">0</span>;</span><br><span class="line">			vis[v]=<span class="number">0</span>;</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span>(now==v)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)&#123;</span><br><span class="line">			sum+=cnt*(cnt<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//memset(ins,0,sizeof(ins));</span></span><br><span class="line">	<span class="comment">//memset(vis,0,sizeof(vis));</span></span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		E[a].push_back(b);</span><br><span class="line">	&#125;</span><br><span class="line">	sum=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])tarjan(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_40400202/article/details/80933131" target="_blank" rel="noopener">https://blog.csdn.net/qq_40400202/article/details/80933131</a></p>
<p><a href="https://baike.baidu.com/item/Tarjan算法/10687825" target="_blank" rel="noopener">https://baike.baidu.com/item/Tarjan算法/10687825</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>map &amp; unordered_map</title>
    <url>/2020/03/16/map-unordered-map/</url>
    <content><![CDATA[<p>摘要：</p>
<p>从内部实现来分析两者的异同与适用范围</p>
<a id="more"></a>

<h2 id="map与unordered-map的区别"><a href="#map与unordered-map的区别" class="headerlink" title="map与unordered_map的区别"></a>map与unordered_map的区别</h2><ul>
<li><p>内部实现不同</p>
<ul>
<li>map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），<strong><em>红黑树具有自动排序的功能，因此map内部的所有元素都是有序的</em></strong>，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</li>
<li>unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，<strong>查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）</strong>。因此，<strong>其元素的排列顺序是无序的</strong>。</li>
</ul>
</li>
<li><p>需要引入的头文件不同</p>
<p>map: <code>#include &lt; map &gt;</code><br>unordered_map: <code>#include &lt; unordered_map &gt;</code></p>
</li>
<li><p>各自的优缺点与适用范围</p>
<ul>
<li>map</li>
</ul>
<p>优点：</p>
<ol>
<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</li>
<li>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</li>
</ol>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p>unordered_map：</p>
<p>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
</li>
</ul>
<h2 id="map和unordered-map的使用"><a href="#map和unordered-map的使用" class="headerlink" title="map和unordered_map的使用"></a>map和unordered_map的使用</h2><ul>
<li>unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/BillCYJ/article/details/78985895" target="_blank" rel="noopener">https://blog.csdn.net/BillCYJ/article/details/78985895</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习笔记</title>
    <url>/2020/03/04/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>摘要：</p>
<p>突击准备面试，奥利给</p>
<p>（将来会持续更新…）</p>
<a id="more"></a>

<h2 id="数学函数、字符和字符串"><a href="#数学函数、字符和字符串" class="headerlink" title="数学函数、字符和字符串"></a>数学函数、字符和字符串</h2><ul>
<li><p>Math是final类：在java.lang.Math中，所有数学函数都是静态方法。</p>
<p>uMath类中定义了常用的数学常量，如</p>
<p>PI : 3.14159265358979323846</p>
<p>E : 2.7182818284590452354（自然对数的底）</p>
<p>u方法:注意都是静态函数</p>
<p>三角函数</p>
<p>sin, cos, tan, asin, acos, atan,toRadians,toDigrees</p>
<p>指数</p>
<p>exp, log, log10，pow, sqrt</p>
<p>取整</p>
<p>ceil, floor, round</p>
<p>其它</p>
<p>min, max, abs, random（[0.0,1.0)）</p>
<ul>
<li><p>扩展：final关键字。</p>
<ul>
<li><p>final修饰类时：当用final去修饰一个类的时候，表示这个类不能被继承。注意：a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。b. final类中的成员方法都会被隐式的指定为final方法。说明：在自己设计一个类的时候，要想好这个类将来是否会被继承，如果可以被继承，则该类不能使用fianl修饰，在这里呢，一般来说工具类我们往往都会设计成为一个fianl类。在JDK中，被设计为final类的有String、System等。</p>
</li>
<li><p>final修饰方法时：被final修饰的方法不能被重写，即不能被子类override。</p>
<p><strong>a. 一个类的private方法会隐式的被指定为final方法。</strong></p>
<p>b. 如果父类中有final修饰的方法，那么子类不能去重写。</p>
</li>
<li><p>final修饰成员变量时，必须初始化而且只能初始化一次。如果成员变量是引用变量，那么相当于和被引用的对象绑定，不能再引用其他对象，被引用对象的值可以改变。</p>
</li>
<li><p>final修饰形参时，表示方法内部不允许对这个参数进行修改，类似于C的const</p>
</li>
</ul>
</li>
<li><p>扩展：静态函数与static关键字</p>
<ul>
<li><p><strong>static关键字;</strong>  </p>
<p>​    <strong>静态成员变量只会在数据共享区中维护一份，而非静态成员变量会在每个对象中维护一份</strong></p>
<p><strong>作用</strong></p>
<p>   <strong>static修饰成员变量</strong>：如果有数据需要共享所有数据使用时</p>
<p>   <strong>static修饰成员函数：</strong>如果一个函数没有直接访问非静态成员时，那么可以使用static修饰，一般用于工具类的方法（创建函数局部变量是ok的，不要和静态成员变量搞混了）</p>
<p><strong>访问方式</strong></p>
<p>  1、 静态修饰成员变量与方法时，可以用类名或者对象进行访问</p>
<p>  2、非静态修饰成员变量与方法时，只能用对象进行访问</p>
<p><strong>静态函数的注意事项</strong>  </p>
<p>​    <strong>1、静态函数可以直接访问静态成员，但不能访问非静态成员</strong></p>
<p>​    <strong>2、非静态函数可以访问静态或者非静态成员</strong></p>
<p>​    <strong>3、静态函数不能出现this、super关键字</strong></p>
</li>
</ul>
</li>
<li><p>Java为每个基本类型实现了对应的包装类，char类型的包装类是Character类。注意包装类对象为引用类型，不是值类型</p>
</li>
<li><p>String类是一个final类，不能被继承。ujava.lang.String表示一个固定长度的字符序列，实例化后其内容不能改。</p>
</li>
<li><p>String m1 = “Welcome”;  //字符串的内容都是不可修改的</p>
<p>String m2 = “Welcome”;    //m1和m2通过内存优化引用了同一常量对象：m1==m2</p>
<p>String m3 = “Wel” +”come”;  //m1==m2==m3 </p>
<p>String m4 = “Wel” +new String(“come”);  //m1!=m4</p>
<ul>
<li><p>由于字符串是不可变的，为了提高效率和节省内存，Java中的字符串字面值维护在字符串常量池中）。这样的字符串称为规范字符串(canonical string)。</p>
</li>
<li><p>可以使用字符串对象（假设内容为Welcome to Java）的intern方法返回规范化字符串。intern方法会在字符串常量池中找是否已存在”Welcome to Java”,如果有返回其地址。如果没有，在池中添加“Welcome to java”再返回地址。即intern方法一定返回一个指向常量池里的字符串对象引用。</p>
</li>
<li><p><strong>直接用字符串字面量构造的字符串在常量池里，如s。用new String方法构造的字符串在堆里，如s1。</strong></p>
<p><strong>只有字面量在常量池里,例如：”Wel” + “come”，而”Wel”+new String(“come”)不在常量池里，在堆里。</strong></p>
</li>
<li><p>扩展：堆</p>
<p>（1）Java的堆是一个运行时数据区，类的对象从堆中分配空间。这些对象通过new等指令建立，通过垃圾回收器来销毁。</p>
<p>（2）堆的优势是可以动态地分配内存空间，需要多少内存空间不必事先告诉编译器，因为它是在运行时动态分配的。但缺点是，由于需要在运行时动态分配内存，所以存取速度较慢。</p>
<p>栈</p>
<p>1）栈中主要存放一些基本数据类型的变量（byte，short，int，long，float，double，boolean，char）和对象的引用。</p>
<p>（2）栈的优势是，存取速度比堆快，栈数据可以共享。但缺点是，存放在栈中的数据占用多少内存空间需要在编译时确定下来，缺乏灵活性。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基本数据类型和字符串间的转换</strong></p>
<ul>
<li><p>valueOf方法将基本数据类型转换为字符串。例如</p>
<p> String s1 = String.valueOf(1.0); //“１.0”</p>
<p> String s2 = String.valueOf(true); //“true”    </p>
</li>
<li><p>字符串转换为基本类型：利用包装类</p>
<p> Double.parseDouble(str)</p>
<p> Integer.parseInt(str)</p>
<p> Boolean.parseBoolean(str)</p>
</li>
</ul>
</li>
<li><p>字符串类型StringBuilder与StringBuffer</p>
<ul>
<li><p>String类一旦初始化完成，字符串就是不可修改的。</p>
</li>
<li><p>StringBuilder与StringBuffer(final类）初始化后还可以修改字符串。</p>
</li>
<li><p>StringBuffer修改缓冲区的方法是同步（synchronized）的，更适合多线程环境。</p>
</li>
<li><p>StringBuilder线程不安全，与StringBuffer工作机制类似。</p>
</li>
<li><p>由于可修改字符串， <strong>StringBuilder</strong> <strong>与</strong>StringBuffer 增加了String类没有的一些函数，例如：append、insert、delete、replace、reverse、setCharAt等。</p>
<p>仅以StringBuilder为例：</p>
<p>StringBuilder stringMy=new StringBuilder( );</p>
<p>StringMy.append(“Welcome to”);</p>
<p>   StringMy.append(“ Java”);</p>
</li>
</ul>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li><p>JDK 1.5引入新的for循环，可以不用下标就可以依次访问数组元素。语法：</p>
<p>for(elementType value : arrayRefVar) {</p>
<p>}</p>
<p>例如</p>
<p>for(int i = 0; i &lt; myList.length; i++) {</p>
<p>  sum += myList[i];</p>
<p>}</p>
</li>
</ul>
<p>  for(double value : myList) {</p>
<p>   sum += value;</p>
<p>  }</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>方法中不能定义static局部变量</li>
<li>每当调用一个方法时，系统将该方法参数、局部变量存储在一个内存区域中，这个内存区域称为调用堆栈(call stack)。当方法结束返回到调用者时，系统自动释放相应的调用栈</li>
<li>方法重载(overloading)是指方法名称相同，但形参列表不同的方法。仅返回类型不同的方法不是合法的重载。一个类中可以包含多个重载的方法（同名的方法可以重载多个版本）。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>数组用new创建后，内存单元都初始化为0（值）或null（引用）</p>
</li>
<li><p>数组元素本身也可以是引用变量</p>
<p>double[ ][ ] myList = new double[4][ ];  //创建一个二维数组</p>
<p>myList[0]=new double[2];  // myList[0]是一个引用变量，指向一个一维数组（2个元素）</p>
<p>myList[3]=new double[3]; // myList[3]是一个引用变量，指向一个一维数组（3个元素）</p>
</li>
<li><p>数组变量是引用类型的变量，声明数组引用变量并不分配数组内存空间。必须通过new实例化数组来分配数组内存空间</p>
</li>
<li><p>String、Integer这样的对象作为参数传递要注意的问题：引用类型的实参传递给形参后，实参、形参指向同一个对象。但是，对于String类、基本数据类型的包装类型的实参传递给形参，形参变了不会导致实参变化。这是为什么？这是因为String、Integer的内容是不可更改的，在Integer内部，用private final int value来保存整数值，在String内部，用private final char value[] 来保存字符串内容。对于String、Integer这样内容不可改变的对象，当对其赋值时实际上创建了一个新的对象。</p>
</li>
<li><p>可变长参数列表：可以把类型相同但个数可变的参数传递给方法。方法中的可变长参数声明如下</p>
<p> typeName … parameterName</p>
<p>在方法声明中，指定类型后面跟省略号</p>
<p>只能给方法指定一个可变长参数，同时该参数必须是最后一个参数</p>
<p>Java将可变长参数当数组看待，通过length属性得到可变参数的个数</p>
<p> print(String… args){  //可看作String [ ]args</p>
<p>   for(String temp:args)</p>
<pre><code>System.out.println(temp);</code></pre><p> System.out.println(args.length);<br>  }</p>
<p>调用该方法</p>
<p> print(“hello”,”lisy”);</p>
</li>
<li><p>Arrays类</p>
<p>ujava.util.Arrays类包括各种静态方法，其中实现了数组的排序和查找</p>
<p>Ø排序</p>
<p>   double[ ] numbers={6.0, 4.4, 1.9, 2.9};</p>
<p>   java.util.Arrays.sort(numbers); //注意直接在原数组排序</p>
<p>Ø二分查找</p>
<p>​    int[ ] list={2, 4, 7, 10, 11, 45, 50};</p>
<p>   int index = java.util.Arrays.binarySearch(list, 11);</p>
</li>
</ul>
<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><ul>
<li><p>当创建对象数组时，数组元素的缺省初值为null。</p>
<p>Circle[] circleArray = new Circle[10]; //这时没有构造Circle对象，只是构造数组</p>
<p>for(int i = 0; i &lt; circleArray.length; i++) {</p>
<p> circleArray[i] = new Circle( );  //这时才构造Circle对象，可使用有参构造函数</p>
<p>}</p>
</li>
<li><p>构造函数</p>
<ul>
<li><p><strong>无返回类型</strong>，名字同类名，用于初始化对象。</p>
</li>
<li><p>注意JAVA如果定义void className(…),被认为是普通方法</p>
</li>
</ul>
<p>只在new时被自动执行。</p>
<ul>
<li><p>必须是实例方法（无static），可为公有、保护、私有和包级权限。</p>
</li>
<li><p>类的变量为引用(相当于C指针)，指向实例化好的对象。</p>
</li>
</ul>
<p>Circle c2=new Circle(5.0);//调用时必须有括弧,可带参初始化</p>
<ul>
<li>缺省构造函数(同C++)</li>
</ul>
<p>如果类未定义任何构造函数，编译器会自动提供一个不带参数的默认构造函数。</p>
<p>如果已自定义构造函数，则不会提供默认构造函数</p>
</li>
<li><p>Java无类似C++的&amp;或C#的ref来修饰方法参数，只能靠形参的声明类型来区分是传值还是传引用，因此一定要注意区分</p>
</li>
<li><p>包</p>
<ul>
<li><p>包是一组相关的类和接口的集合。将类和接口分装在不同的包中，可以避免重名类的冲突，更有效地管理众多的类和接口。因此package就是C++里的namespace</p>
</li>
<li><p>包的定义通过关键字package来实现的 ，package语句的一般形式：</p>
<p>  package 包名; </p>
<p>package语句必须出现在.java文件第一行，前面不能有注释行也不能有空白行，该.java文件里定义的所有内容（类、接口、枚举）都属于package所定义的包里。如果.java文件第一行没有package语句，则该文件定义的所有内容位于default包（缺省名字空间），但不推荐。</p>
<p>不同.java文件里的内容都可以属于同一个包，只要它们第一条package语句的包名相同</p>
</li>
<li><p>package本质上就是C++里的namespace，因此</p>
<p>在同一个package里不能定义同名的标识符（类名，接口名，枚举名）。例如一个类名和一个接口名不能相同</p>
<p>如果要使用其它包里标识符，有二个办法：</p>
<p>用完全限定名，例如要调用java.util包里的Arrays类的sort方法： java.util.Arrays.sort(list)；</p>
<p>在package语句后面，先引入要使用其它包里的标识符，再使用：</p>
<p> import java.util.Arrays; //或者： import java.util.*; </p>
<p> Arrays.sort(list)；</p>
<p>import语句可以有多条，分别引入多个包里的名字</p>
</li>
</ul>
</li>
<li><p>包的命名习惯: 将Internet域名作为包名 （但级别顺序相反），这样的好处是避免包名的重复</p>
<p>org.apache.tools.zip</p>
<p>cn.edu.hust.cs.javacourse.ch1</p>
<p>如果所有程序员都遵循这种包命名的约定，包名重复的可能性就非常小</p>
</li>
<li><p>数据成员的封装</p>
<ul>
<li><p>面向对象的封装性要求最好把实例成员变量设为私有的或保护的</p>
</li>
<li><p>同时为私有、保护的实例成员变量提供公有的get和set方法。get和set方法遵循JavaBean的命名规范</p>
</li>
<li><p>设成员为DateType propertyName。</p>
</li>
<li><p>get用于获取成员值：public DateType getPropertyName( ); </p>
</li>
<li><p>set用于设置成员值：public void setPropertyName(DateType value)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> radius=<span class="number">1.0</span>;    <span class="comment">//数据成员设为私有</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">( )</span></span>&#123; radius=<span class="number">1.0</span>; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">( )</span></span>&#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123; radius=r; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="comment">/** 私有静态变量，记录当前内存里被实例化的Circle对象个数*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numberOfObjects = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123; radius = <span class="number">1.0</span>; numberOfObjects++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> newRadius)</span> </span>&#123; radius = newRadius; numberOfObjects++; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> radius;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> newRadius)</span> </span>&#123; radius = newRadius;&#125;</span><br><span class="line">    <span class="comment">/** 公有静态方法，获取私有静态变量内容*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumberOfObjects</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> numberOfObjects;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Return the area of this circle */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> radius * radius * Math.PI; &#125;</span><br><span class="line">  <span class="comment">/*覆盖从Object继承的finalize方法，该方法在对象被回收时调用，方法里对象计数器-1。注意该方法调用时机不可控制。 @Override是注解(annotation)</span></span><br><span class="line"><span class="comment">告诉编译器这里是覆盖父类的方法。</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        numberOfObjects--; <span class="comment">//对象被析构时，计数器减1</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法重载（overload)、方法重写（override）、方法隐藏</p>
<ul>
<li><p>方法重载：同一个类中、或者父类子类中的多个方法具有相同的名字，但这些方法具有不同的参数列表(不含返回类型，即无法以返回类型作为方法重载的区分标准）</p>
</li>
<li><p>方法重写和方法隐藏：发生在父类和子类之间，前提是继承。子类中定义的方法与父类中的方法具有相同的方法名字、相同的参数列表、相同的返回类型（也允许子类中方法的返回类型是父类中方法返回类型的子类）</p>
</li>
<li><p>方法重写：实例方法</p>
</li>
<li><p>方法隐藏：静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面语句报错m(int,int)已经定义, 重载函数不能通过返回类型区分</span></span><br><span class="line"><span class="comment">//    public int m(int x, int y) &#123; return 0;&#125;; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; <span class="comment">//B继承了A</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123; &#125; <span class="comment">//重载了父类的m(int,int)和m(double,double)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125; <span class="comment">//覆盖了父类的void m(int,int)，注意连返回类型都必须一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意下面这个语句报错，既不是覆盖（与父类的void m(int,int)返回类型不一样）</span></span><br><span class="line">    <span class="comment">// 也不是合法的重载（和父类的m(int,int)参数完全一样，只是返回类型不一致</span></span><br><span class="line"><span class="comment">//    public int m(int x, int y) &#123;&#125; //错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子类定义了新的重载函数int m()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可见性修饰符</p>
<ul>
<li><p>Java继承时无继承控制(见继承，即都是公有继承，和C++不同)，故父类成员继承到派生类时访问权限保持不变。</p>
</li>
<li><p>成员访问控制符的作用：</p>
<ul>
<li><p>private： 只能被当前类定义的函数访问。</p>
</li>
<li><p>包级：只能被同一包中的类访问（成员没有显示表明访问修饰符时，默认访问控制符为包级packdge）</p>
</li>
<li><p>protected：直接子类（是否同一包中均可）、同一包中的类的函数可以访问。</p>
</li>
<li><p>public： 所有类的函数都可以访问。</p>
</li>
<li><p>注意：若不加访问控制符，则默认为包级，而包级只能被同一包中的类访问，不能被子类访问</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><ul>
<li><p>如果class C1 extends C2，则称C1为子类(subclass)，C2为父类(superclass)。</p>
</li>
<li><p>子类继承了父类中可访问的数据和方法，子类也可添加新的数据和方法</p>
</li>
<li><p>子类不继承父类的构造函数。</p>
</li>
<li><p>一个类只能有一个直接父类（Java不支持多重继承，因为Java的设计者认为没有必要）</p>
</li>
<li><p>Java的继承都是公有继承，因此被继承的就是父类，继承的类就是子类。因此父类的成员如果被继承到子类，访问权限不变</p>
</li>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometricObject</span> </span>&#123; <span class="comment">//等价于public class GeometricObject extends Object</span></span><br><span class="line">    <span class="keyword">private</span> String color = <span class="string">"white"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> filled;</span><br><span class="line">    <span class="keyword">private</span> Date dateCreated; <span class="comment">//java.util.Date是JDK定义的类，表示日期和时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeometricObject</span><span class="params">()</span> </span>&#123; dateCreated = <span class="keyword">new</span> Date();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123; <span class="keyword">this</span>.color = color;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFilled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> filled; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilled</span><span class="params">(<span class="keyword">boolean</span> filled)</span> </span>&#123; <span class="keyword">this</span>.filled = filled;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDateCreated</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> dateCreated;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//覆盖Object类的toString()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">( )</span> </span>&#123; <span class="comment">//还应考虑equals，clone</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"created on "</span> + dateCreated + <span class="string">"\n\tcolor: "</span> + color</span><br><span class="line">				+ <span class="string">" and filled: "</span> + filled;</span><br><span class="line">   &#125;<span class="comment">//toString方法应该返回一个描述当前对象的有意义的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">GeometricObject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> radius; <span class="comment">//新增属性</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123; &#125;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123; <span class="keyword">this</span>.radius = radius; &#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span> <span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123; <span class="keyword">this</span>.radius = radius; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> radius * radius * Math.PI;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDiameter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * radius * Math.PI;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//还应考虑equals，clone，toString等函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">GeometricObject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> width, <span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.width = width;</span><br><span class="line">		<span class="keyword">this</span>.height = height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> width; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span> <span class="params">(<span class="keyword">double</span> width)</span> </span>&#123; <span class="keyword">this</span>.width = width;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> height;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span> <span class="params">(<span class="keyword">double</span> height)</span> </span>&#123; <span class="keyword">this</span>.height = height;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> width * height;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * (width + height);</span><br><span class="line">	&#125;</span><br><span class="line">         <span class="comment">//还应考虑equals，clone，toString等函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例初始化模块</p>
<ul>
<li><p>初始化块是Java类中可以出现的第四种成员（前三种包括属性、方法、构造函数），分为实例初始化块和静态初始化块。</p>
</li>
<li><p>实例初始化模块（instance initialization block，IIB）是一个用大括号括住的语句块，直接嵌套于类体中，不在方法内。</p>
</li>
<li><p>它的作用就像把它放在了类中每个构造方法的最开始位置。用于初始化对象。实例初始化块先于构造函数执行</p>
</li>
<li><p>作用：如果多个构造方法共享一段代码，并且每个构造方法不会调用其他构造方法，那么可以把这段公共代码放在初始化模块中。</p>
</li>
<li><p>一个类可以有多个初始化模块，模块按照在类中出现的顺序执行</p>
</li>
<li><p>下面的两段代码等价</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numOfObjects;</span><br><span class="line">  <span class="keyword">private</span> String title</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String title)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    numOfObjects++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numOfObjects;</span><br><span class="line">  <span class="keyword">private</span> String title</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String title)</span></span>&#123;</span><br><span class="line">    numOfObjects++;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    numOfObjects++;</span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实例初始化模块最重要的作用是当我们需要写一个内部匿名类时：匿名类不可能有构造函数，这时可以用实例初始化块来初始化数据成员.•实例初始化模块还有个作用是可以截获异常</p>
</li>
<li><p>实例初始化模块只有在创建类的实例时才会被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;		<span class="comment">//执行次序：1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;		<span class="comment">//执行次序：4</span></span><br><span class="line">    <span class="keyword">this</span>.id = id		</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//实例初始化块			//执行次序：2</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//实例初始化块			//执行次序：3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>静态初始化模块</p>
<ul>
<li><p>•静态初始化模块是由static修饰的初始化模块{}，只能访问类的静态成员，<strong>并且在JVM的Class Loader将类装入内存时调用</strong>。（类的装入和类的实例化是两个不同步骤，<strong><em>首先是将类装入内存，然后再实例化类的对象</em></strong>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;	<span class="comment">//执行次序：1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	 <span class="keyword">this</span>.id = id 		    		</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="comment">//静态初始化块			//执行次序：2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="comment">//静态初始化块			//执行次序：3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>初始化模块执行顺序</strong></p>
<ul>
<li><p>第一次使用类时装入类</p>
<ul>
<li><p>如果父类没装入则首先装入父类，这是个递归的过程，直到继承链上所有祖先类全部装入</p>
</li>
<li><p>装入一个类时，类的静态数据成员和静态初始化模块按它们在类中出现的顺序执行</p>
</li>
</ul>
</li>
<li><p>实例化类的对象</p>
<ul>
<li>首先构造父类对象，这是个递归过程，直到继承链上所有祖先类的对象构造好</li>
<li>构造一个类的对象时，按在类中出现的顺序执行实例数据成员的初始化及实例初始化模块</li>
<li>执行构造函数函数体</li>
</ul>
</li>
<li><p>例子（输出为012345678）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitDemo</span></span>&#123;</span><br><span class="line">    InitDemo()&#123;</span><br><span class="line">        <span class="keyword">new</span> M();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	  System.out.println(<span class="string">"(1) "</span>);</span><br><span class="line">	  <span class="keyword">new</span> InitDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"(2) "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"(0) "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">N</span></span>&#123;</span><br><span class="line">    N()&#123; 	System.out.println(<span class="string">"(6) "</span>); &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"(5) "</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"(3) "</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span> <span class="keyword">extends</span> <span class="title">N</span></span>&#123;</span><br><span class="line">    M()&#123; 	System.out.println(<span class="string">"(8) "</span>); &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"(7) "</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"(4) "</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>匿名内部类</strong>也就是没有名字的内部类</p>
<p>正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</p>
<p>但使用匿名内部类还有个前提条件：<strong>必须继承一个父类或实现一个接口</strong></p>
</li>
</ul>
<p>  实例1:不使用匿名内部类来实现抽象方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Child();</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>  <strong>运行结果：</strong>eat something</p>
<p>  可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用</p>
<p>  但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p>
<p>  这个时候就引入了匿名内部类</p>
<p>  实例2：匿名内部类的基本实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>  <strong>运行结果：</strong>eat something</p>
<p>  可以看到，我们直接将抽象类Person中的方法在大括号中实现了</p>
<p>  这样便可以省略一个类的书写</p>
<p>  并且，匿名内部类还能用于接口上</p>
<p>  实例3：在接口上使用匿名内部类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>运行结果：</strong>eat something</p>
<p>  由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p>
<p>  最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口</p>
<p>  实例4：Thread类的匿名内部类实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>运行结果：</strong>1 2 3 4 5</p>
<p>  实例5：Runnable接口的匿名内部类实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>  <strong>运行结果：</strong>1 2 3 4 5</p>
<ul>
<li><p>super关键字</p>
<ul>
<li><p>利用super可以显式调用父类的构造函数</p>
<ul>
<li><p>super(parametersopt)调用父类的的构造函数。</p>
</li>
<li><p>必须是子类构造函数的第1条且仅1条语句(先构造父类)。</p>
</li>
<li><p>如果子类构造函数中没有显式地调用父类的构造函数，那么将自动调用父类不带参数的构造函数。</p>
</li>
<li><p>父类的构造函数在子类构造函数之前执行。</p>
</li>
</ul>
</li>
<li><p>调用父类的成员（这时super类似于this引用，只不过是指向父类对象）</p>
<ul>
<li><p>super.data（如果父类属性在子类可访问）</p>
</li>
<li><p>super.method(parameters)（如果父类方法在子类可访问）</p>
</li>
<li><p>Circle代码里可以写getDataCreated()或super.getDataCreated()</p>
</li>
<li><p>不能使用super.super.p()这样的super链</p>
</li>
</ul>
</li>
<li><p>编译器在为子类添加无参构造函数时，函数体里会用super( )默认调用父类的无参构造函数，如果找不到父类无参构造函数，则编译器为子类添加无参构造函数失败，编译报错。如果一个类定义了带参数的构造函数，<strong>一定别忘了定义一个无参的构造函数</strong>，原因是：由于系统不会再自动加上无参构造函数，就造成该类没有无参构造函数，那么在被继承时如果子类构造函数没有显式调用父类的带参构造函数，就会自动执行父类的无参构造函数，但是父类没有无参构造函数，这时就会出错</p>
</li>
</ul>
</li>
<li><p>多态</p>
<ul>
<li><p>多态：通过引用变量调用实例函数时，根据所引用的实际对象的类型，执行该类型的相应实例方法，从而表现出不同的行为称为多态。通过继承时覆盖父类的实例方法实现多态。多态实现的原理：在运行时根据引用变量指向对象的实际类型，重新计算调用方法的入口地址（晚期绑定）。</p>
</li>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;  <span class="function"><span class="keyword">void</span> <span class="title">Greeting</span><span class="params">( )</span></span>&#123; System.out.println(“Best wish from a person!<span class="string">"); &#125; &#125;</span></span><br><span class="line"><span class="string">class Employee extends Person</span></span><br><span class="line"><span class="string">	      &#123;	void Greeting( )&#123; System.out.println(“Best wish from a employee!"</span>);&#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123; </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Greeting</span><span class="params">( )</span></span>&#123; System.out.println(“Best wish from a manager!<span class="string">");&#125; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public class GreetingTest1&#123;</span></span><br><span class="line"><span class="string">    public static void main(String[] args)&#123;</span></span><br><span class="line"><span class="string">       //父类引用变量可以引用本类和子类对象，p1,p2,p3的声明类型都是Person(父类型），p2,p3执行子类对象</span></span><br><span class="line"><span class="string">       Person p1= new Person( ),p2= new Employee( ),p3= new Manager( );      </span></span><br><span class="line"><span class="string">	p1.Greeting( ); //调用Person的Greeting()    ，由于实际指向对象类型是Person</span></span><br><span class="line"><span class="string"> 	p2.Greeting( ); //调用Employee的Greeting()  ，由于实际指向对象类型是Employee</span></span><br><span class="line"><span class="string"> 	p3.Greeting( ); //调用Manager的Greeting()   ，由于实际指向对象类型是Manager</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingSender</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newYearGreeting</span> <span class="params">(Person p)</span></span>&#123; p.Greeting(); <span class="comment">//编译时应该是Person的Greeing&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingTest1</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	GreetingSender g = <span class="keyword">new</span> GreetingSender();</span><br><span class="line">       	g.newYearGreeting(<span class="keyword">new</span> Person()); 	<span class="comment">//调用Person的Greeting()</span></span><br><span class="line">       	g.newYearGreeting(<span class="keyword">new</span> Employee());	<span class="comment">//调用Employee的Greeting()</span></span><br><span class="line">       	g.newYearGreeting(<span class="keyword">new</span> Manager());	<span class="comment">//调用Manager的Greeting()</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以最后一条语句为例来解释多态特性：</span></span><br><span class="line"><span class="comment">当实参new Manager()传给形参Person p时，等价于Person p = new Manager(), 因此执行p.Greeting()语句时根据形参p指向的对象的实际类型动态计算Greeting方法的入口地址，调用了Manager的Greeting()*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段程序的微妙之处在于：</p>
<p>GreetingSender类的newYearGreeting方法的参数是Person类型，那么</p>
<p>newYearGreeting的行为应该是Person对象的行为。</p>
<p>但是在实际运行时我们看到随着实参对象类型的变化， newYearGreeting</p>
<p>方法却表现出了多种不同的行为，这种机制称为多态</p>
</li>
<li><p>仔细观察程序，可以发现产生多态的三个重要因素：</p>
<p><strong>1：不同类之间有继承链</strong></p>
<p><strong>2：newYearGreeting方法的参数类型用的父类类型</strong></p>
<p><strong>3：newYearGreeting调用的Greeting方法都被子类用自己的行为覆盖</strong></p>
<p>满足了这三个条件，用继承链中不同子类的对象做为方法的实参去调用方法会使该方法表现出不同的行为。由于子类的实例也是父类的实例，所以用子类对象作为实参传给方法中的父类型的形参是没有问题的。</p>
</li>
</ul>
</li>
<li><p>当调用实例方法时，由Java虚拟机动态地决定所调用的方法，称为动态绑定(dynamic binding)或者晚期绑定或者延迟绑定(lazy binding)或者多态。</p>
</li>
<li><p><strong>通用编程：方法参数和变量的声明类型越抽象越好，越抽象越通用</strong></p>
</li>
<li><p>当编译器检查到 Manager m = p；编译器认为Person类型引用p要赋值给类型为Manager类型引用，扩展内存可能引起麻烦且不安全，因此，编译器认为类型不匹配，会报错。</p>
<p>加上强制转换 Manager m = (Manager)p；意思是强烈要求编译器，把p解释成Manager类型，风险我来承担。这个时候编译器就按Manager类型来解释p</p>
<p>因此，强制类型转换意味着你自己承担风险，编译器不会再做类型检查。</p>
<p>强制类型转换的风险是：运行时如果p指向的对象不是Manager的实例时程序会出错。</p>
<p>为了避免风险，最好用instanceof来做实例类型检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（p <span class="keyword">instanceof</span> Manager）</span><br><span class="line">			Manager m = （Manager）p；</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载发生在编译时(Compile time)，编译时编译器根据实参比对重载方法的形参找到最合适的方法。</p>
<p>多态发生在运行(Run time)时，运行时JVM根据变量所引用的对象的真正类型来找到最合适的实例方法。</p>
<p>有的书上把重载叫做“编译时多态”，或者叫“早期绑定”(早期指编译时)。</p>
<p>多态是晚期绑定(晚期指运行时)</p>
<p>绑定是指找到函数的入口地址的过程。</p>
</li>
</ul>
</li>
</ul>
<h2 id="异常处理和文本IO"><a href="#异常处理和文本IO" class="headerlink" title="异常处理和文本IO"></a>异常处理和文本IO</h2><ul>
<li><p>文本：非二进制文件(参见FileInputStream、FileOutputStream)。</p>
<p>类库：java.io.File、java.util.Scanner、java.io.PrinterWriter。</p>
<p>类File： 对文件和目录的抽象，包括：路径管理，文件读写状态、修改日期获取等。</p>
<p>类Scanner：从File或InputStream的读入。可按串、字节、整数、双精度、或整行等不同要求读入。</p>
<p>类PrinterWriter ： 输出到File或OutputStream： 可按串、字节、整数、双精度、或整行等不同要求输出。</p>
</li>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span>  filecopy;</span><br><span class="line"><span class="keyword">import</span> java.lang.System;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> </span>&#123;  <span class="comment">//参数不含程序名</span></span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: Java  Copy  &lt;sourceFile&gt;   &lt;tagetFile&gt;"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        File sF=<span class="keyword">new</span> File(args[<span class="number">0</span>]);                     <span class="comment">//args[0]:源文件路径</span></span><br><span class="line">        <span class="keyword">if</span>(!sF.exists( ))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Source Fiel "</span>+args[<span class="number">0</span>]+ <span class="string">"does not exist!"</span>);</span><br><span class="line">            System.exit(<span class="number">2</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">File tF=<span class="keyword">new</span> File(args[<span class="number">1</span>]);      <span class="comment">//args[1]:目标文件</span></span><br><span class="line">        <span class="keyword">if</span>(tF.exists( ))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Target File "</span>+args[<span class="number">0</span>]+ <span class="string">"already exist"</span>);</span><br><span class="line">            System.exit(<span class="number">3</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Scanner input=<span class="keyword">new</span> Scanner(sF);</span><br><span class="line">            PrintWriter output=<span class="keyword">new</span> PrintWriter(tF);</span><br><span class="line">            <span class="keyword">while</span>(input.hasNext( ))&#123;</span><br><span class="line">                String s=input.nextLine(); <span class="comment">//读取下一行</span></span><br><span class="line">                output.println(s);		<span class="comment">//打印这一行</span></span><br><span class="line">            &#125;</span><br><span class="line">            input.close( );       </span><br><span class="line">            output.close( );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IOException ioe)&#123;       </span><br><span class="line">		System.out.println(ioe.toString( ));      </span><br><span class="line">	 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><ul>
<li><p>Java可定义不含方法体的方法，其方法体由子类根据具体情况实现，这样的方法称为抽象方法(abstract method)，包含抽象方法的类必须是抽象类(abstract class)。</p>
</li>
<li><p>抽象类和抽象方法的声明必须加上abstract关键字。</p>
</li>
<li><p>抽象方法的意义：加给子类的一个约束。例如Circle类和Rectangle类计算面积必须使用父类规定的函数签名。这样可以充分利用多态特性使得代码变得更通用</p>
</li>
<li><p>抽象方法：使用abstract定义的方法或者接口中定义的方法（接口中定义的方法自动是抽象的，可以省略abstract）</p>
</li>
<li><p>一个类C如果满足下面的任一条件，则该类包含抽象方法且是抽象类：</p>
<ul>
<li><p>类C显式地包含一个抽象方法的声明；</p>
</li>
<li><p>类C的父类中声明的抽象方法未在类C中实现；</p>
</li>
<li><p>类C所实现的接口中有的方法在类C里没有实现</p>
</li>
<li><p>只要类C有一个未实现的方法（自己定义的或继承的），就是抽象类</p>
</li>
<li><p>但是，一个不包含任何抽象方法的类，也可以定义成抽象类</p>
</li>
</ul>
</li>
<li><p>抽象类不能被实例化，即不能用new关键字创建对象（即new 右边的类型不能是抽象类）。</p>
<p> 但是抽象类可以作为变量声明类型、方法参数类型、方法返回类型</p>
<p>为什么？因为一个抽象类型引用变量可以指向具体子类的对象</p>
<p>抽象类可以定义构造函数，并可以被子类调用。</p>
<p>抽象类可以定义变量、非抽象方法并被子类使用</p>
<p>抽象类的父类可以是具体类：自己引入了抽象方法。例如，具体类Object是所有类的祖先父类。</p>
</li>
<li><p>接口是公共静态常量和公共抽象实例方法的集合。接口是能力、规范、协议的反映。</p>
<p>接口不是类：(1)不能定义构造函数；(2)接口之间可以多继承，类可implements多个接口。(3)和抽象类一样，不能new一个接口</p>
</li>
<li><p>接口中的所有数据字段隐含为public static final</p>
<p>接口体中的所有方法隐含为public abstract</p>
</li>
<li><p>接口不是类（Java支持单继承类），一个接口可以继承多个接口。</p>
<p> 语法</p>
<p> [<em>modifier*] interface *interfaceName</em> [extends <em>interfaceName*</em>List*] {</p>
<p> declaration*</p>
<p> }</p>
<p> 如果接口声明中提供了extends子句，那么该接口就继承了父接口的方法和常量。被继承的接口称为声明接口的直接父接口。</p>
<p> 任何实现该接口的类，必须实现该接口继承的其他接口</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201604_2 俄罗斯方块</title>
    <url>/2020/02/17/csp-201604-2-%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    <content><![CDATA[<p>摘要：</p>
<p>注意细节！注意审题！</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。<br>　　游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。<br>　　在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。<br>　　具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。<br>　　输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。<br>　　第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 1 0 0<br>0 0 0 0 0 0 1 0 0 0<br>0 0 0 0 0 0 1 0 0 0<br>1 1 1 0 0 0 1 1 1 1<br>0 0 0 0 1 0 0 0 0 0<br>0 0 0 0<br>0 1 1 1<br>0 0 0 1<br>0 0 0 0<br>3</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 1 0 0<br>0 0 0 0 0 0 1 0 0 0<br>0 0 0 0 0 0 1 0 0 0<br>1 1 1 1 1 1 1 1 1 1<br>0 0 0 0 1 1 0 0 0 0</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">15</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> block[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;<span class="comment">//四个方块的坐标</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; col;</span><br><span class="line"><span class="keyword">int</span> icol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"201604_2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> dline=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; block[i][j];</span><br><span class="line">            <span class="keyword">if</span>(block[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                line.push_back(i);</span><br><span class="line">                col.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; icol;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">map</span>[dline+line[<span class="number">0</span>]+<span class="number">1</span>][col[<span class="number">0</span>]+icol<span class="number">-1</span>]^block[line[<span class="number">0</span>]][col[<span class="number">0</span>]] &amp;&amp; <span class="built_in">map</span>[dline+line[<span class="number">1</span>]+<span class="number">1</span>][col[<span class="number">1</span>]+icol<span class="number">-1</span>]^block[line[<span class="number">1</span>]][col[<span class="number">1</span>]] &amp;&amp; <span class="built_in">map</span>[dline+line[<span class="number">2</span>]+<span class="number">1</span>][col[<span class="number">2</span>]+icol<span class="number">-1</span>]^block[line[<span class="number">2</span>]][col[<span class="number">2</span>]] &amp;&amp; <span class="built_in">map</span>[dline+line[<span class="number">3</span>]+<span class="number">1</span>][col[<span class="number">3</span>]+icol<span class="number">-1</span>]^block[line[<span class="number">3</span>]][col[<span class="number">3</span>]])&#123;</span><br><span class="line">        dline++;</span><br><span class="line">        <span class="keyword">if</span>(dline+line[<span class="number">0</span>]==<span class="number">14</span> || dline+line[<span class="number">1</span>]==<span class="number">14</span> || dline+line[<span class="number">2</span>]==<span class="number">14</span> || dline+line[<span class="number">3</span>]==<span class="number">14</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">map</span>[dline+line[i]][col[i]+icol<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">map</span>[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">9</span>) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题思路不难，但是0分了好久才最后AC，原因在于我一开始输出的时候没有注意到所有的数字需要用空格隔开，修复了这个bug之后马上就AC了，这种情况如果出现在真正的考试中绝对血亏，相当于白给100分，之后在做题过程中一定要注意，审清题目，看好输出的格式和要求。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu下qt环境配置</title>
    <url>/2020/02/11/ubuntu%E4%B8%8Bqt%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>摘要：</p>
<p>第一次使用qt，亲自踩坑整理出来的，记录一下</p>
<a id="more"></a>

<h2 id="下载QT"><a href="#下载QT" class="headerlink" title="下载QT"></a>下载QT</h2><p>点击<a href="https://download.qt.io/archive/qt/" target="_blank" rel="noopener">这里</a>下载即可，我下载的是qt-opensource-linux-x64-5.7.1.run。</p>
<p>下载下来之后运行安装即可，QT库和QT creator都会被安装。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如果我们不进行配置，直接新建一个工程来运行的话，我这边会报错说“Error while building/deploying project XXX when executing step ‘qmake’”。我分析的原因有两个，一个是ubuntu系统本身自带qt库，我们还没有指定qt creator去使用我们新安装的qt库；另一个原因是我们还没有配置qmake的路径，qt creator找不到qmake。解决方法如下。</p>
<ol>
<li><p>首先打开终端输入下面的指令安装qtchooser</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install qtchooser</span><br></pre></td></tr></table></figure>

<p>安装它是因为我们希望借助这个工具来指定我们当前想要使用的qt版本。</p>
</li>
<li><p>增加我们新下载的那个qt环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qtchooser -install qt5.7 &#x2F;home&#x2F;zhangyazhe&#x2F;Qt5.7.1&#x2F;5.7&#x2F;gcc_64&#x2F;bin&#x2F;qmake</span><br></pre></td></tr></table></figure>

<p>qt5.7是这个环境的name，可以随意起。后面的路径是qmake的路径。</p>
</li>
<li><p>设置下环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export QT_SELECT&#x3D;qt5.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>经过上面的操作，qmake就配置好了，可以执行qmake -v来查看版本。这个时候再运行工程，不会再显示qmake出错，而是开始显示make出错，这时候执行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libqt4-dev</span><br></pre></td></tr></table></figure>

<p>之后再尝试运行就ok了。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201503_4 网络延迟</title>
    <url>/2020/02/09/csp-201503-4-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F/</url>
    <content><![CDATA[<p>摘要：</p>
<p>树的直径 dfs</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定一个公司的网络，由<em>n</em>台交换机和<em>m</em>台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。<br>　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示交换机的台数和终端电脑的台数。<br>　　第二行包含<em>n</em> - 1个整数，分别表示第2、3、……、<em>n</em>台交换机所连接的比自己上一层的交换机的编号。第<em>i</em>台交换机所连接的上一层的交换机编号一定比自己的编号小。<br>　　第三行包含<em>m</em>个整数，分别表示第1、2、……、<em>m</em>台终端电脑所连接的交换机的编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示消息传递最多需要的步数。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>4 2<br>1 1 3<br>2 1</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>4</p>
<h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><p>4 4<br>1 2 2<br>3 4 4 4</p>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><p>4</p>
<h3 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h3><p>电脑1与电脑4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　前30%的评测用例满足：<em>n</em> ≤ 5, <em>m</em> ≤ 5。<br>　　前50%的评测用例满足：<em>n</em> ≤ 20, <em>m</em> ≤ 20。<br>　　前70%的评测用例满足：<em>n</em> ≤ 100, <em>m</em> ≤ 100。<br>　　所有评测用例都满足：1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 10000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是经典的求树的直径的问题，这种问题一般有两种解法，一种是dfs一种是dp，我使用的是dfs的方法。树的直径有一个性质：对于树中的任意一个结点，找到距离它最远的那个点，记为点u。再寻找树中距离点u最远的那个点，记为点v，那么点u与点v之间的距离，即为树的直径。这个性质在这里不再证明，网上可以查到证明过程。有了这个性质，我们的思路就是，先随便找一个点进行dfs，找到距离这个点最远的点u，再从u开始dfs找到树的直径。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>; <span class="comment">//因为n m 相加需要20000</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> maxCost,number;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</span><br><span class="line">        G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>; <span class="comment">//是否通过</span></span><br><span class="line">    <span class="keyword">if</span>(maxCost&lt;cost)</span><br><span class="line">    &#123;</span><br><span class="line">        maxCost=cost; <span class="comment">//记录最长路径距离 因为有回溯所以需要全局变量</span></span><br><span class="line">        number=u;  <span class="comment">//记录最长距离的最后一个点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[u].size(); i++) <span class="comment">//对U的每一个邻接点遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[G[u][i]])  <span class="comment">//若该邻接点未标记，则距离加1，继续递归调用</span></span><br><span class="line">            dfs(G[u][i],cost+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,x,i;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n+m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        G[i].push_back(x);<span class="comment">//第i个的前一个  机器顺延交换机顺序</span></span><br><span class="line">        G[x].push_back(i);<span class="comment">//无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxCost=<span class="number">-1</span>;  <span class="comment">//每次调用dfs函数时，首先要对最大值初始化为-1，且vis初始化为0</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//访问变量初始化</span></span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    maxCost=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dfs(number,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxCost&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>通过编译linux内核增加具有拷贝功能的系统调用</title>
    <url>/2020/02/08/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8%E5%A2%9E%E5%8A%A0%E5%85%B7%E6%9C%89%E6%8B%B7%E8%B4%9D%E5%8A%9F%E8%83%BD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>摘要：</p>
<p>通过编译linux内核的方式，增加一个新的系统调用。另外编写一个应用程序来测试和使用新增加的系统调用。其中，新增加的系统调用具有文件拷贝功能。</p>
<a id="more"></a>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>我们都知道，很多我们习以为常的C语言标准函数，在linux平台的实现都是通过系统调用完成的，例如我们在用户程序中使用open()或者write()函数时，函数执行过程中会通过中断进入到系统内核中，在Intel CPU中，这个由中断INT0x80实现。跳转到的内核位置叫做sysem_call。检查系统调用号，这个号码代表进程请求哪种服务。然后，它查看系统调用表(sys_call_table)找到所调用的内核函数入口地址。接着，就调用内核函数来实现open()或者write()等函数的功能。我们要做的，就是在内核中增加一个内核函数，相应地也在系统调用表中增加一个表项，使得我们增加的功能永远的留存在系统中。</p>
<h2 id="系统说明"><a href="#系统说明" class="headerlink" title="系统说明"></a>系统说明</h2><p>我使用的是电脑是macbook pro，做这个实验用的是vmware中的ubuntu18.04.3虚拟机。</p>
<h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>首先我们要进行一些准备工作，安装相关依赖。打开终端输入下列命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libncurses5-dev libssl-dev</span><br><span class="line">sudo apt-get install build-essential openssl</span><br><span class="line">sudo apt-get install zlibc minizip</span><br><span class="line">sudo apt-get install libidn11-dev libidn11</span><br><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install flex</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Snoopy是个小机灵」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;snoopy19981210&#x2F;article&#x2F;details&#x2F;89957254</span><br></pre></td></tr></table></figure>

<p>之后，我们并不会直接编译我们现在使用的ubuntu的linux内核，因为有可能会把系统搞崩代价太大，所以采取的方法是单独下载一个linux内核，我是从<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" target="_blank" rel="noopener">清华的镜像网站</a>下载的，下载的linux内核版本为4.18.3。</p>
<p>下载之后会得到一个压缩包，解压。</p>
<p>之后用<strong>sudo mv linux-4.18.3 /usr/src</strong>命令，将该文件夹移动至/usr/src。</p>
<p>然后找到/usr/src/linux-4.18.3/arch/x86/entry/syscalls/syscall_64.tbl，我的理解是，syscall_64.tbl就是系统调用表，程序运行时，内核会通过这个表找到系统调用程序的位置。我们打开这个文件，可以看到每行第一列都有一个编号，第三列是系统调用的名字。我们在编号为334的一行后面新加一行，编号为335，第二列为common，第三列为新增系统调用的名字，我命名为mycall，第四列为__x64_sys_mycall。</p>
<p>之后找到/usr/src/linux-4.18.3/include/linux/syscalls.h，从文件名字就能看出来，这里面的都是函数的声明，我们在文件的最后，#endif之前，添加我们自定义的函数的声明.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asmlinkage long sys_mycall(char *src, char *dest);</span><br></pre></td></tr></table></figure>

<p>最前面的asmlinkage表示函数参数将存放在局部栈中，系统调用大多都采取这种方式。然后因为我们要实现的是文件拷贝功能，所以参数列表中是源文件的文件名和目标文件的文件名。</p>
<p>之后，找到/usr/src/linux-4.18.3/kernel/sys.c，我们将新增加的函数的定义添加在文件的末尾，#endif之前。</p>
<p>接下来需要重点说一下函数定义该怎么写，即拷贝系统调用如何实现。</p>
<p>首先需要注意的是，在内核中，我们只能使用内核函数，比如open()、write()函数都不能用了，需要用ksys_open()和ksys_write()。</p>
<p>ksys_open()函数的原型为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">ksys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>flags定义文件打开方式，O_RDONLY表示以只读方式打开，O_WRONLY表示可读可写方式打开，O_CREAT表示要打开的文件不存在时自动创建文件。</p>
<p>mode定义权限，S_IRUSR表示允许用户读文件，S_IWUSR表示允许用户写文件。</p>
<p>下面的函数名和参数列表肯定会让你疑惑，往下看，代码后面会解释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE2(mycall,<span class="keyword">char</span> *,src,<span class="keyword">char</span> *,dest)&#123;</span><br><span class="line">	<span class="keyword">int</span> fs,fd,len;</span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">mm_segment_t</span> fss;</span><br><span class="line"> 	fss = get_fs();</span><br><span class="line"> 	set_fs(KERNEL_DS);</span><br><span class="line">	fs=ksys_open(src,O_RDONLY,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(fs==<span class="number">-1</span>)&#123;</span><br><span class="line">		printk(<span class="string">"source file error,maybe it doesn't exist.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fd=ksys_open(dest,O_CREAT|O_WRONLY|O_TRUNC,S_IRUSR|S_IWUSR);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		printk(<span class="string">"fail to create destination.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>((len=ksys_read(fs,<span class="built_in">buffer</span>,<span class="number">50</span>))&gt;<span class="number">0</span>)</span><br><span class="line">		ksys_write(fd,<span class="built_in">buffer</span>,len);</span><br><span class="line">	ksys_close(fs);</span><br><span class="line">	ksys_close(fd);</span><br><span class="line">	set_fs(fss);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，函数名我们用的是SYSCALL_DEFINE2，并且本来应该是参数应该是char * sourceFile，却被我写成了char *, sourceFile，打开sys.c文件我们会发现，许多函数都是这样写的，如果不想去深究，我们只需要知道2代表着参数列表中参数的个数，参数列表中变量类型与变量名之间要加逗号，如果想仔细探究下，可以参考<a href="https://blog.csdn.net/hxmhyp/article/details/22699669" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>接下来进行编译内核前的准备工作，终端输入下列指令。其中第二条指令用来清除编译过程中所有的中间文件，第三条指令用于清除上一次编译的中间文件，第三条指令用于生成.config文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;src&#x2F;linux-4.18.3</span><br><span class="line">sudo make mrproper</span><br><span class="line">sudo make clean</span><br><span class="line">sudo make menuconfig</span><br></pre></td></tr></table></figure>

<p>在出现的界面中不需要任何操作直接exit。</p>
<p>接下来开始编译内核，输入指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>

<p>输入指令后，内核就开始编译了，这个过程会比较久。如果出了错，重新编译前应该重新输入一次上面的sudo make mrproper、sudo make clean和sudo make menuconfig命令。</p>
<p>编译完成后，生成了新的内核，我们安装新生成的内核。输入指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make modules_install</span><br><span class="line">sudo make install</span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>

<p>完成之后，我们的新内核就算是编译好了，接下来进行测试。</p>
<p>重启虚拟机，启动时同时按住esc和shift，在弹出的界面选择ubuntu高级选项，选择新编译的那个内核来启动系统。</p>
<p>启动后，执行下面的测试程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	i = syscall(<span class="number">335</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Success!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i = %d"</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果程序输出“Success!”而且源文件内容被成功复制到目标文件，那么任务就完成了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/snoopy19981210/article/details/89957254" target="_blank" rel="noopener">https://blog.csdn.net/snoopy19981210/article/details/89957254</a></li>
<li><a href="https://blog.csdn.net/qq84395064/article/details/86593469" target="_blank" rel="noopener">https://blog.csdn.net/qq84395064/article/details/86593469</a></li>
<li><a href="https://blog.csdn.net/hxmhyp/article/details/22699669" target="_blank" rel="noopener">https://blog.csdn.net/hxmhyp/article/details/22699669</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201412_4 最优灌溉</title>
    <url>/2020/02/07/csp-201412-4-%E6%9C%80%E4%BC%98%E7%81%8C%E6%BA%89/</url>
    <content><![CDATA[<p>摘要：</p>
<p>最小生成树 prim算法</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。<br>　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。<br>　　现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。<br>　　接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>4 4<br>1 2 1<br>2 3 4<br>2 4 2<br>3 4 3</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>6</p>
<h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>　　建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。</p>
<p>###评测用例规模与约定</p>
<p>　　前20%的评测用例满足：n≤5。<br>　　前40%的评测用例满足：n≤20。<br>　　前60%的评测用例满足：n≤100。<br>　　所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不得不说早年的csp考试题目果然很直接。。这道题直接套用prim算法的模板就行甚至都不需要小trick。在这里顺便把prim算法重新说下吧，prim算法主要用来构建最小生成树，算法的主要思想是，所有的点构成点集V，已经被我们访问的点构成点集S，所以点集V就被分为了点集S和点集V-S。我们每次都要从点集V-S中寻找一个距离点集S最近的点加入到点集S中，这个最近的距离所对应的那条边就被加入到最小生成树中。实现的时候，我们需要一个数组d[]，他记录的是<strong>各个节点到集合S的距离</strong>，这道题我是使用邻接矩阵来实现的。一些坑和需要注意的点会在代码注释里面写出来。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];    <span class="comment">//借调到集合S的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] = &#123;<span class="literal">false</span>&#125;;   <span class="comment">//  记录是否被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//默认以第一个节点作为起点</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    fill(d, d+MAXN, INF);   <span class="comment">//注意：fill的第一个和第二个参数应该是指针，所以不要写成了d[0]</span></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min_n = <span class="number">-1</span>, min = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; min)&#123;</span><br><span class="line">                min = d[j];</span><br><span class="line">                min_n = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_n == <span class="number">-1</span>)&#123;    <span class="comment">//注意:这个判断在这道题中似乎是不需要的，但是规范的prim算法应该需要这个判断，当给出的图不是一个连通分量的时候应该返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += min;</span><br><span class="line">        vis[min_n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAXN; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G[min_n][j] &lt; d[j] &amp;&amp; vis[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                d[j] = G[min_n][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    fill(G[<span class="number">0</span>], G[<span class="number">0</span>]+MAXN*MAXN, INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="comment">//注意：题目给出的节点的序号是从1开始的，而我们的数组是从0开始，所以需要减一</span></span><br><span class="line">        <span class="comment">//注意：给G[a-1][b-1]赋值后不要忘记给G[b-1][a-1]赋值，我一开始就忘了=_=</span></span><br><span class="line">        G[a<span class="number">-1</span>][b<span class="number">-1</span>] = c;</span><br><span class="line">        G[b<span class="number">-1</span>][a<span class="number">-1</span>] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; prim(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201409_4 最优配餐</title>
    <url>/2020/02/06/csp-201409-4-%E6%9C%80%E4%BC%98%E9%85%8D%E9%A4%90/</url>
    <content><![CDATA[<p>摘要：</p>
<p>多源最短路径 bfs</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　栋栋最近开了一家餐饮连锁店，提供外卖服务。随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。<br>　　栋栋的连锁店所在的区域可以看成是一个n×n的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。<br>　　方格图中的线表示可以行走的道路，相邻两个格点的距离为1。栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyazhe/CDN@v1.0/p41.png" alt="题目"></p>
<p>送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费1块钱。每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。<br>　　现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含四个整数n, m, k, d，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。<br>　　接下来m行，每行两个整数xi, yi，表示栋栋的一个分店在方格图中的横坐标和纵坐标。<br>　　接下来k行，每行三个整数xi, yi, ci，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）<br>　　接下来d行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示最优送餐方式下所需要花费的成本。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>10 2 3 3<br>1 1<br>8 8<br>1 5 1<br>2 3 3<br>6 7 2<br>1 2<br>2 2<br>6 8</p>
<p>###样例输出</p>
<p>29</p>
<p>###评测用例规模与约定</p>
<p>　　前30%的评测用例满足：1&lt;=n &lt;=20。<br>　　前60%的评测用例满足：1&lt;=n&lt;=100。<br>　　所有评测用例都满足：1&lt;=n&lt;=1000，1&lt;=m, k, d&lt;=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这种给出格点给出坐标然后求最短路径的问题，第一反应是用bfs，仔细看完题目之后发现这道题是多源最短路径，其实只要bfs稍微变一变就ok。方法就是，初始化的时候将所有的起点都入队列，然后多个起点同时开始bfs。对于每一个起点来说，每一轮循环都会使他们向前探索一步，所以他们入队列的顺序并不会对结果产生影响。</p>
<p>有一个坑需要注意，就是评测用例规模：“1&lt;=n&lt;=1000，1&lt;=m, k, d&lt;=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。”，考虑一种容易考虑的情况，即若左下角(1,1)有唯一一家分店，右上角(1000,1000)有1000,000个顾客，每个顾客的订餐量为1000，无禁止通过的点。那么，从分店(1,1)走到顾客所在的点(1000,1000)需要<strong>2000</strong>步左右；然后1000,000个顾客，每人订餐量1000，总订餐量10^9，总共花费2000 * 10^9 = 2 * 10^12，显然这超出了int的范围，所以要使用long long类型。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point_info</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Legal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;n)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> customer_need[MAX_SIZE+<span class="number">1</span>][MAX_SIZE+<span class="number">1</span>] = &#123;<span class="number">0L</span>L&#125;;<span class="comment">//记录一个点所有顾客的总需求 </span></span><br><span class="line"><span class="keyword">int</span> customers[MAX_SIZE+<span class="number">1</span>][MAX_SIZE+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//记录同一点有几个顾客 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,k,d,x,y;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>,value;</span><br><span class="line">	<span class="built_in">queue</span>&lt;point_info&gt; q;</span><br><span class="line">	<span class="keyword">bool</span> ban[MAX_SIZE+<span class="number">1</span>][MAX_SIZE+<span class="number">1</span>] = &#123;<span class="literal">false</span>&#125;; <span class="comment">//  不能走的位置</span></span><br><span class="line">	point_info front,t;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> move[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;k,&amp;d);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="comment">//初始化时，将所有的起点全部入队列</span></span><br><span class="line">		point_info start;</span><br><span class="line">		start.step = <span class="number">0L</span>L;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;start.x,&amp;start.y);</span><br><span class="line">		ban[start.x][start.y] = <span class="literal">true</span>;   <span class="comment">//餐厅的位置不能走</span></span><br><span class="line">		q.push(start);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="comment">//同一个位置不论有多少客户或者多少需求，都一定是由距离最近的那个餐厅进行配送，所以直接将需求加在一起就行</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %lld"</span>,&amp;x,&amp;y,&amp;value);</span><br><span class="line">		customer_need[x][y] += value;</span><br><span class="line">		customers[x][y]++; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(d--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">		ban[x][y] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		front = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(customer_need[front.x][front.y]!=<span class="number">0L</span>L)&#123;</span><br><span class="line">			k -= customers[front.x][front.y];</span><br><span class="line">			ans += front.step * customer_need[front.x][front.y];</span><br><span class="line">			<span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			x = front.x+move[i][<span class="number">0</span>];</span><br><span class="line">			y = front.y+move[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(Legal(x,y,n)&amp;&amp;!ban[x][y])&#123;</span><br><span class="line">				t.x = x;</span><br><span class="line">				t.y = y;</span><br><span class="line">				t.step = front.step + <span class="number">1</span>;</span><br><span class="line">				ban[x][y] = <span class="literal">true</span>;</span><br><span class="line">				q.push(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201403_4 无线网络</title>
    <url>/2020/02/05/csp-201403-4-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>摘要：</p>
<p>最短路径 bfs</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。<br>　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。<br>　　接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。<br>　　接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。<br>　　输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>5 3 1 3<br>0 0<br>5 5<br>0 3<br>0 5<br>3 5<br>3 3<br>4 4<br>3 0</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>2</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>路由器构成了一个图，如果两个路由器之间的距离小于r则存在边。问题要求解的是最短路径，所有边的权都为1，考虑使用BFS。搜索时要记录已经增设的路由器数量，确保路由器数量不超过k。</p>
<h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 210</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;    <span class="comment">//序号</span></span><br><span class="line">    <span class="keyword">int</span> new_router_num; <span class="comment">//新增路由器数量</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">//路径长度</span></span><br><span class="line">    node(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):num(a), new_router_num(b), length(c)&#123;&#125;    <span class="comment">//构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K, R;</span><br><span class="line"><span class="keyword">bool</span> graph[MAXN][MAXN];	<span class="comment">//graph[i][j]的值代表着第i个点和第j个点之间是否有边，即第i个点与第j个点之间的距离是否小于r </span></span><br><span class="line"><span class="keyword">int</span> pos[MAXN][<span class="number">2</span>];	<span class="comment">//每行代表一个元素，两列分别是x坐标和y坐标 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inRange</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pos[a][<span class="number">0</span>]-pos[b][<span class="number">0</span>],<span class="number">2</span>)+<span class="built_in">pow</span>(pos[a][<span class="number">1</span>]-pos[b][<span class="number">1</span>],<span class="number">2</span>))&lt;=R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(M+N)</span></span>;	<span class="comment">//记录某结点是否被访问过 </span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node &gt; q;</span><br><span class="line">    <span class="function">node <span class="title">start</span><span class="params">(s, <span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    q.push(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node f = q.front();</span><br><span class="line">        <span class="keyword">if</span>(f.num == t) <span class="keyword">return</span> f.length<span class="number">-2</span>;	<span class="comment">//到达了终点 </span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;	<span class="comment">//不考虑新增路由器的情况下选择路径的下一个结点 </span></span><br><span class="line">            <span class="keyword">if</span>(graph[f.num][i] &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                <span class="function">node <span class="title">temp</span><span class="params">(i, f.new_router_num, f.length + <span class="number">1</span>)</span></span>;   <span class="comment">//因为不考虑新增路由器，所以f.new_router_num不变 </span></span><br><span class="line">                q.push(temp);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N; i&lt;N+M; i++) &#123;	<span class="comment">//仅考虑新增路由器的情况下选择路径的下一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(graph[f.num][i] &amp;&amp; !visited[i] &amp;&amp; f.new_router_num&lt;K) &#123;</span><br><span class="line">                <span class="function">node <span class="title">temp</span><span class="params">(i, f.new_router_num + <span class="number">1</span>, f.length + <span class="number">1</span>)</span></span>;</span><br><span class="line">                q.push(temp);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;N, &amp;M, &amp;K, &amp;R);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N+M; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;pos[i][<span class="number">0</span>], &amp;pos[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N+M; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;N+M; j++) &#123;</span><br><span class="line">            graph[i][j] = graph[j][i] = inRange(i, j, R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, bfs(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201812_2小明放学（C++）AC代码</title>
    <url>/2020/01/31/csp-201812-2%E5%B0%8F%E6%98%8E%E6%94%BE%E5%AD%A6%EF%BC%88C-%EF%BC%89AC%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>摘要：</p>
<p>汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。</p>
<a id="more"></a>

<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了出发时刻路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 10^6^。<br>　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。<br>　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 10^6^；k=1、2、3 时，分别表示出发时刻，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。<br>输出格式<br>　　输出一个数字，表示此次小明放学回家所用的时间。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>30 3 30<br>8<br>0 10<br>1 5<br>0 11<br>2 2<br>0 6<br>0 3<br>3 10<br>0 3</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>46</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。<br>评测用例规模与约定<br>　　有些测试点具有特殊的性质：<br>　　* 前 2 个测试点中不存在任何信号灯。<br>　　测试点的输入数据规模：<br>　　* 前 6 个测试点保证 n ≤ 10^3^。<br>　　* 所有测试点保证 n ≤ 10^5^。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>1.由于每个信号灯的类型会随着时间的推移而改变，所以定义信号灯结构体，结构体中包含目前信号灯的类型以及距离下一次信号类型发生改变剩余的时间。<br>2.问题的核心在于，求出经过t时间后，小明达到某个红绿灯时，红绿灯的类型以及剩余时间。只需要记录好小明到达某个红绿灯时已经使用的时间，即可推算此时红绿灯是什么类型。由于红绿灯是每经过(r+g+y)s就会循环一次，故使用t%(r+g+y)来推断红绿灯类型，如果不这样做会超时<br>3.需要注意，题目中已经说明，经过一段路所需时间和红绿灯等待时间均最多为10^6^s，道路的段数n最大为10^5^，那么小明回家所需时间最大就有可能是10^11^，此时已经超过int型数据所能表示的范围，故代码中的整数均直接定义成long long类型。<br>4.要注意黄灯结束后紧接着是红灯，依然需要等待</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//容易出错的点</span></span><br><span class="line"><span class="comment">//1.由于数据量大，t需要定义成long longl类型</span></span><br><span class="line"><span class="comment">//2.黄灯结束后，还需要紧接着等红灯</span></span><br><span class="line"><span class="comment">//3.小心超时</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义结构体，其中包含类型和时间两个信息。</span></span><br><span class="line"><span class="comment">// 另外构造一个函数，用于计算某一个红绿灯经过t时间后是什么类型的灯以及剩余多少时间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sig</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> time_left;</span><br><span class="line">&#125;sig;</span><br><span class="line"><span class="function">sig <span class="title">next_state</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> y, <span class="keyword">int</span> g, sig p, <span class="keyword">long</span> <span class="keyword">long</span> t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, y, g, n, i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;</span><br><span class="line">    sig p, ret_sig;</span><br><span class="line">    <span class="built_in">vector</span>&lt;sig&gt; state;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; y &gt;&gt; g;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p.type &gt;&gt; p.time_left;</span><br><span class="line">        <span class="built_in">cin</span>.get();</span><br><span class="line">        state.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        p = state[i];</span><br><span class="line">        <span class="keyword">if</span>(p.type == <span class="number">0</span>)&#123;</span><br><span class="line">            t+=p.time_left;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            ret_sig = next_state(r, y, g, state[i], t);</span><br><span class="line">            <span class="keyword">if</span>(ret_sig.type == <span class="number">1</span>)&#123;</span><br><span class="line">                t+=ret_sig.time_left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret_sig.type == <span class="number">2</span>)&#123;</span><br><span class="line">            	t+=ret_sig.time_left;</span><br><span class="line">            	t+=r;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sig <span class="title">next_state</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> y, <span class="keyword">int</span> g, sig p, <span class="keyword">long</span> <span class="keyword">long</span> t)</span></span>&#123;</span><br><span class="line">    sig ret_sig;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">4</span>];</span><br><span class="line">    time[<span class="number">1</span>]=r;</span><br><span class="line">    time[<span class="number">2</span>]=y;</span><br><span class="line">    time[<span class="number">3</span>]=g;</span><br><span class="line">    ret_sig.type = p.type;</span><br><span class="line">    ret_sig.time_left = p.time_left;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;r+g+y)&#123;</span><br><span class="line">    	t=t%(r+g+y);<span class="comment">//important point to optimize the time cost</span></span><br><span class="line">	&#125;</span><br><span class="line">    ret_sig.time_left-=t;</span><br><span class="line">    <span class="keyword">if</span>(ret_sig.time_left&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ret_sig.type--;</span><br><span class="line">            <span class="keyword">if</span>(ret_sig.type == <span class="number">0</span>) ret_sig.type=<span class="number">3</span>;</span><br><span class="line">            ret_sig.time_left+=time[ret_sig.type];</span><br><span class="line">        &#125;<span class="keyword">while</span> (ret_sig.time_left&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_sig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2020/01/30/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>摘要：</p>
<p>依据廖雪峰的教程和网上其他一些博客的内容整理，涵盖了平时比较常用的指令和操作，适合于零基础的同学。可能会有表述不合适的地方，欢迎指正。</p>
<a id="more"></a>

<ul>
<li>创建版本仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;新建一个文件夹，使用git init命令</span><br><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure></li>
<li>把一个文件放到Git仓库需要两步   <ol>
<li>$ git add readme.txt</li>
<li>$ git commit -m “wrote a readme file”<br>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</li>
</ol>
</li>
<li>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure></li>
<li>git status命令可以让我们时刻掌握仓库当前的状态，下面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li>
<li>使用git diff可以查看对文件进行的修改<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a&#x2F;readme.txt</span><br><span class="line">+++ b&#x2F;readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure></li>
<li>git log查看历史记录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)&#x2F;&#x2F;版本号</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></li>
<li>git reset命令可以回退到之前的版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure></li>
<li>如果从A回退到B之后后悔了，又想返回A，这时必须查看历史记录找到A的版本号，然后使用git reset. 如果这中间关掉了终端，导致历史的命令行记录看不了，可以使用 git reflog 命令查看之前的命令，然后就可以找到之前的版本号<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a&#x2F;&#x2F;版本号不需要写全，只写前几位就ok</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></li>
<li>比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone.一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone.一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:michaelliao&#x2F;bootstrap.git</span><br></pre></td></tr></table></figure></li>
<li>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送.<br>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</li>
<li>合并分支<br><a href="https://cloud.tencent.com/developer/news/242399" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/242399</a></li>
<li>github使用流程   <ol>
<li>在本地新建一个文件夹，并且执行init add commit操作</li>
<li>使用  git remote add origin <a href="mailto:git@github.com">git@github.com</a>:zhangyazhe/仓库名.git 命令将本地仓库与远程仓库建立连接</li>
<li>在push之前，先pull一下，保证本地仓库和远程仓库是一样的，否则会报错，即执行 git pull –rebase origin master</li>
<li>下一步，就可以把本地库的所有内容推送到远程库上：使用git push -u origin master , 这里实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。从这之后，就可以通过git push origin master来进行push</li>
</ol>
</li>
<li>进行git push时可能会出现下面的问题：   <ol>
<li>git 出现 fatal: refusing to merge unrelated histories 错误。其实这个问题是因为两个根本不相干的git库，一个是本地库，一个是远端库，然后本地要去推送到远端，远端觉得这个本地库跟自己不相干，所以告知无法合并。这个错误可以忽略</li>
<li>有时候会出现无法push的情况，可能是因为远程仓库用有README但是本地没有，这样就出现了冲突。在git pull中添加了–rebase之后，就可以将远程仓库有但是本地仓库没有的文件下载下来，从而解决了冲突。例如，执行完带有–rebase之后，本地仓库就会出现README。命令为 git pull –rebase origin master</li>
<li>建议是在github上面新建repo的时候不要加上README，而是在本地仓库中加上README。这样一来远程是空的，就不会有冲突。</li>
</ol>
</li>
<li>使用删除本地仓库中的文件之后使用git add *和git commit和git push之后，发现远程仓库中的对应文件并没有被删除，这是因为使用git add *的话，并没有包含删除信息。这个时候可以使用git add –all或者git add -A，这样一来远程仓库对应为文件也会被删除</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>模电复习笔记</title>
    <url>/2020/01/30/%E6%A8%A1%E7%94%B5%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>摘要：</p>
<p>这篇博文是大二的时候学习模拟电子技术时候期末复习的笔记，适用于华中科技大学的学弟学妹们，结合华中科技大学mooc模电课程效果更佳</p>
<a id="more"></a>

<h1 id="模拟电子技术基础期末复习"><a href="#模拟电子技术基础期末复习" class="headerlink" title="模拟电子技术基础期末复习"></a>模拟电子技术基础期末复习</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><ul>
<li>描述放大电路输出量与输入量之间关系的曲线称为传输特性曲线。<h2 id="第二章-运算放大器"><a href="#第二章-运算放大器" class="headerlink" title="第二章 运算放大器"></a>第二章 运算放大器</h2></li>
<li>开环电压增益即运放由输出端到输入端无外接反馈元件事的电压增益，运放电路的功能是用来放大两个输入信号的差值。</li>
<li>运放的增益越高，线性区的直线越陡，输入电压的线性范围越小。</li>
<li>如果直接将电压源接在运放的两端，基本都会超过线性区而导致失真，这才引入了负反馈，主要目的是通过负反馈来减小加载输入端的信号从而保证工作在线性区。这时的线性工作区会明显变大，这时的增益成为闭环增益Av。</li>
<li>电压跟随器可以增大输出电阻，帮助负载抢夺电压，提高了电路的带负载能力。</li>
<li>运放只有工作在线性区，虚短才成立。因为只有在线性区才有开环电压增益为无穷大，才能根据输出电压有限推出输出电压近似为零。</li>
<li>深度负反馈是虚短的条件</li>
<li>实际运放由负反馈链接的线路也可以得到虚短和虚断的概念，与理想运放特性相同</li>
<li>运放构成的放大电路的指标与运算放大器本身的指标含义是不同的。</li>
<li>反馈电阻必须加在反向端与输出端之间，否则不是负反馈。</li>
<li>对于虚地，只是表明这个节点的电压可以近似视为零，但它并不是真的接地。<h2 id="第三章-二极管及其基本电路"><a href="#第三章-二极管及其基本电路" class="headerlink" title="第三章 二极管及其基本电路"></a>第三章 二极管及其基本电路</h2></li>
<li>本征激发，温度引起。</li>
<li>电场导致的是漂移，浓度导致的是扩散。</li>
<li>P区点位高于N区点位时，称之为正向偏置。</li>
<li><code>反向电流IR，反向饱和电流Is,VT温度电压当量，常温下为26mv，VBR为反向击穿电压，Vth开启电压</code></li>
<li>二极管大信号模型：理想模型、恒压降模型、折现模型。</li>
<li><code>通常，小信号模型中，二极管两端电流为ID，二极管两端电压VD，二极管动态电阻rd。其中，rd=VT/ID。</code></li>
<li>在二极管小信号模型中，微变电阻rd=VT/ID。其中VT=26mv，ID由静态工作点决定</li>
<li>在已知特性曲线的前提下，可以使用图解法建立小信号模型。<h2 id="第四章-场效应三极管及其放大电路"><a href="#第四章-场效应三极管及其放大电路" class="headerlink" title="第四章 场效应三极管及其放大电路"></a>第四章 场效应三极管及其放大电路</h2></li>
<li>由于vgs可以控制漏极电流，所以常常将GS作为输入端口，将DS作为输出端口。</li>
<li>场效应管的放大作用就是通过vgs对漏极电流的控制实现的，所以用场效应管放大信号时，需要让场效应管工作在饱和区。对于vgs和漏极电流之间的关系的研究在使用场效应管对信号进行放大的过程中十分重要。</li>
<li>考虑沟道长度调制效应时，饱和区的输出特性曲线是倾斜的，其斜率就是输出端口的电阻rds的倒数。rds也称为动态电阻或交流电阻。根据表达式，vgs确定后，rds也就确定了。</li>
<li>转移特性直接反映了输入电压对输出电流的控制作用，由于用于放大信号的场效应管必须工作在饱和区，所以我们只对饱和区进行讨论。根据饱和区电流计算公式，即可画出转移特性曲线。在曲线上某一点Q做切线，切线的斜率就是电导，由于这个是联系输入端口电压和输出端口电流，所以又称为跨导或互导。用gm表示。可以发现，Q点位置不同，gm也不同。跨导将输入端口电压vgs与漏极电流id联系了起来。</li>
<li>（图4.2.1）通常来讲，输入的vGS是交流量和直流量的叠加，所以漏极电流和漏源电压也是直流量和交流量的叠加。</li>
<li>iD=ID+id。三者的大小写字母匹配为：总量=直流量+交流量。</li>
<li>（图4.2.1）由漏极回路看出，漏极电流方向不会反转，当电流id减小到0时，输出电压达到最大值，等于VDD。当电流id增大，可以使得输出电压接近于零，所以输出电压vds一定是在0到VDD之间。如果VGG或者Rd选择不恰当，使得vDSQ过高或者过低，都会导致输出波形明显失真。（图4.3.5、图4.3.6）</li>
<li>必须让MOSFET工作在饱和区，别且有合适的静态偏置。</li>
<li>信号经常又被叫做交流量或者变化量。</li>
<li>输出信号的幅值受输出回路电源电压的限制。</li>
<li>直流电源既是MOSFET正常工作的前提条件，优势信号放大的能量供给者。</li>
<li>求出静态指标后，需要校验是否满足饱和区的工作条件。</li>
<li>解题时一般先假设工作在饱和区，利用饱和区特性方程求解，最后验证是否工作在饱和区。<h4 id="图解法"><a href="#图解法" class="headerlink" title="图解法"></a>图解法</h4></li>
<li>求交流负载线方程时，首先根据交流通路图写出交流量之间的关系，接着利用‘交流量=总量-直流量’这个关系待入交流量的方程，即可得到vDS与iD之间的关系，就可以画在输出特性图里面了。（书P111）<h4 id="小信号模型分析法"><a href="#小信号模型分析法" class="headerlink" title="小信号模型分析法"></a>小信号模型分析法</h4></li>
<li>由于栅极是绝缘的，所以栅源之间的端口是开路状态。如果考虑沟道长度调制效应，那么在输出端口就有一个输出电阻rds。</li>
<li>跨导是转移特性曲线上Q点切线的斜率。输出电阻是传输特性曲线上Q点斜率的倒数。</li>
<li>受控源的电流方向和控制电压的极性是关联的，改变其中一个，另外一个也要改变。<h4 id="共源极、共栅极、共漏极放大电路"><a href="#共源极、共栅极、共漏极放大电路" class="headerlink" title="共源极、共栅极、共漏极放大电路"></a>共源极、共栅极、共漏极放大电路</h4></li>
<li>计算放大电路输入电阻时，不考虑信号源内阻。</li>
<li>放大电路的组态与静态偏置无关，所以不同的组态具有不同的动态指标，而相同的组态，即使静态偏置方式不同，他们的动态指标也是基本相同的。<h4 id="多级放大电路"><a href="#多级放大电路" class="headerlink" title="多级放大电路"></a>多级放大电路</h4></li>
<li>前级的开路电压是后级的信号源电压</li>
<li>前级的输出电阻是后级的信号源内阻</li>
<li>对于共源-共漏放大电路，虽然共漏的增益约等于一，但是由于其输入电阻很大，可以使得前一级增益变大，同时由于共漏的输出电阻很小，两级总增益还是会比单共源提高不少<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4></li>
<li>判断电路对信号是否有放大作用，首先判断静态偏置是否合理，是否满足线性区的要求。其次判断交流通路。最后总的观察通路是否畅通或是否短路。<h2 id="第五章-双极结型三极管及其放大电路"><a href="#第五章-双极结型三极管及其放大电路" class="headerlink" title="第五章 双极结型三极管及其放大电路"></a>第五章 双极结型三极管及其放大电路</h2><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4></li>
<li>PN结外加正向电压时，耗尽区变窄，外加反向电压时，耗尽区变宽</li>
<li>发射结电压与集电极电流的控制关系：发射结电压与发射极电流的关系就是之前的PN结正偏时的电压电流关系（近似指数），发射结电压增大后，发射极电流也增大，会有更多的电子进入到基区，进而导致更多的电子进入到集电区，而集电极电流主要就是由这部分电子形成，所以发射结电压能够控制集电极电流</li>
<li>ICBO是在PN结外加反向电压形成的，即为反向饱和电流，电流较小</li>
<li>一旦三极管制成，α和β的值就确定了</li>
<li>BJT工作的外部条件：发射结正偏，集电结反偏</li>
<li>用BJT放大信号时，一般是通过改变发射结正偏电压，来改变基极电流或发射极电流，从而控制集电极电流，所以通常发射极和基极作为输入端，集电极总是在输出回路中</li>
<li>在BJT中，电子和空穴都参与了导电，所以称为双极结型</li>
<li>BJT的输出特性曲线：当vCE固定时，若iB增加，意味着一定是因为发射结电压增加，必然同时引起发射极电流增加，从而会导致集电极电流增加</li>
<li>截止区的形成是因为发射结的正向偏置电压小于开启电压</li>
<li>由于基区宽度调制效应，vCE增加会导致基区有效宽度减小，载流子在基区复合的机会变小，使得电流放大系数β增加，所以输出特性曲线上翘</li>
<li>描述静态工作点时，通常使用IBQ ICQ VCEQ<h4 id="BJT的静态偏置和放大电路构成"><a href="#BJT的静态偏置和放大电路构成" class="headerlink" title="BJT的静态偏置和放大电路构成"></a>BJT的静态偏置和放大电路构成</h4></li>
<li>一般硅管VBEQ=0.7V，锗管VBEQ=0.2V<h4 id="BJT的小信号等效模型"><a href="#BJT的小信号等效模型" class="headerlink" title="BJT的小信号等效模型"></a>BJT的小信号等效模型</h4></li>
<li>（图5.3.11）受控源βib的电流方向和控制电流ib的方向是关联的</li>
<li>因为bjt小信号模型反映的是电压电流变化量之间的关系，所以与NPN或者PNP型无关</li>
<li>（图5.4.2）计算Re输入等效电阻，使用p186的方法</li>
<li>（图5.4.2）引入Re后，增益会下降，但是可以减小非线性失真，增大放大电路的频带宽度（实际是负反馈）<h4 id="MOS与BJT的比较"><a href="#MOS与BJT的比较" class="headerlink" title="MOS与BJT的比较"></a>MOS与BJT的比较</h4></li>
<li>两种三极管的六种组态可以分为三类：反向电压放大器（增益高、输入电阻大）、电压跟随器（输入电阻高、输出电阻低）、电流跟随器（输入电阻小）<h4 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h4></li>
<li>交流通路中，将二极管用小信号模型等效，再去掉直流电源，最终只剩下rd。计算方法见p66<h2 id="第六章-放大电路的频率响应"><a href="#第六章-放大电路的频率响应" class="headerlink" title="第六章 放大电路的频率响应"></a>第六章 放大电路的频率响应</h2><h4 id="单时间常数RC电路的频率响应"><a href="#单时间常数RC电路的频率响应" class="headerlink" title="单时间常数RC电路的频率响应"></a>单时间常数RC电路的频率响应</h4></li>
<li>AVM中的M指的是中频区<h4 id="三极管放大电路的高频响应"><a href="#三极管放大电路的高频响应" class="headerlink" title="三极管放大电路的高频响应"></a>三极管放大电路的高频响应</h4></li>
<li>当MOS管和信号源确定后，增益带宽积为定值<h2 id="第七章-模拟集成电路"><a href="#第七章-模拟集成电路" class="headerlink" title="第七章 模拟集成电路"></a>第七章 模拟集成电路</h2><h4 id="集成电路中的直流偏置——电流源电路"><a href="#集成电路中的直流偏置——电流源电路" class="headerlink" title="集成电路中的直流偏置——电流源电路"></a>集成电路中的直流偏置——电流源电路</h4></li>
<li>在集成电路中，一个三极管比一个电阻所占用的面积更小，所以一般不采用电阻来作为偏置，而是采用三极管构成直流电流源，为放大管提供静态偏置</li>
<li>三极管做电流源时，vGS始终是恒定的，对应一条不变的输出特性曲线，当负载改变时，负载线的斜率发生变化，但是交点始终在输出特性曲线上，漏极电流是不会改变的，便达到恒流效果</li>
<li>根据以上可以看出，MOS做电流源时，必须满足两个条件：一是vGS保持不变，二是MOS必须工作在饱和区（这样才能保证静态工作点在输出特性曲线的水平部分移动）</li>
<li>饱和区输出特性曲线的斜率的倒数，实际上就是电流源的内阻。忽略沟道长度调制效应时，内阻为无穷大<h4 id="差分式放大电路"><a href="#差分式放大电路" class="headerlink" title="差分式放大电路"></a>差分式放大电路</h4></li>
<li>只有直接耦合放大电路才会有零点漂移问题<h4 id="MOSFET源极耦合差分式放大电路"><a href="#MOSFET源极耦合差分式放大电路" class="headerlink" title="MOSFET源极耦合差分式放大电路"></a>MOSFET源极耦合差分式放大电路</h4></li>
<li>双端输出是单端输出幅值的两倍</li>
<li>单端输入时的差模情况等效于双端输入</li>
<li>无论何种输出方式，共模增益都远小于差模增益。这是因为ro的影响</li>
<li>差分式放大电路的输入电阻分为两类，差模输入电阻和共模输入电阻</li>
<li>差分式放大电路对共模信号有很强的放大能力而对差摸信号有很强的抑制能力，产生这种作用的根本原因是源极公共支路，方法差摸信号时，源极公共支路相当于短路，而放大共模信号时，公共支路不再短路，支路上的电阻会明显影响增益的大小<h4 id="BJT差分式放大电路"><a href="#BJT差分式放大电路" class="headerlink" title="BJT差分式放大电路"></a>BJT差分式放大电路</h4></li>
<li>由于BJT的基极不再像栅极那样是绝缘的，所以输入电阻不再是无穷大<h4 id="集成运算放大器简介"><a href="#集成运算放大器简介" class="headerlink" title="集成运算放大器简介"></a>集成运算放大器简介</h4></li>
<li>一般都可以分为输入级、中间级、输出级。输入级通常是高共模抑制比的差分式放大电路，输出级主要特点是具有较强的驱动负载的能力</li>
<li>高增益是集成运放的最基本特征<h4 id="集成运放的主要参数"><a href="#集成运放的主要参数" class="headerlink" title="集成运放的主要参数"></a>集成运放的主要参数</h4></li>
<li>三极管一定需要有直流通路，这样三极管才能有合适的静态工作点。如此一来，运放的两输入端就会有一定的静态电流。</li>
<li>失调电流、偏置电流等并不影响虚短和虚断的正常使用 </li>
<li>运放的输入端必须要有直流通路，运放里面的差分放大电流才能有合适的偏置<h2 id="第八章-反馈放大电路"><a href="#第八章-反馈放大电路" class="headerlink" title="第八章 反馈放大电路"></a>第八章 反馈放大电路</h2><h4 id="反馈的基本概念与分类"><a href="#反馈的基本概念与分类" class="headerlink" title="反馈的基本概念与分类"></a>反馈的基本概念与分类</h4></li>
<li>没有明显反馈线的负反馈：例如图4.5.1（a）。源极电阻就是反馈通路，漏极电流就是输出电流，他会在源极电阻上产生压降，这个压降会影响g与s之间的电压，进而影响到漏极电流，所以构成了反馈通路</li>
<li>根据反馈到输入端信号的性质，来区分交流反馈还是直流反馈</li>
<li>理想情况下，电源线和地线不是反馈通路，因为他们上面的电压始终是恒定的。</li>
<li>对于电流信号源，使用并联反馈效果更明显。对于电压信号源，使用串联反馈效果更明显。原因都在于，反馈电压或电流的变化可以直接影响经输入电压或电流的变化</li>
<li>判断依据：并联反馈的特点是，输入信号和反馈信号接在同一个输入端上。而串联反馈输入信号和反馈信号一般接在不同输入端上</li>
<li>串联反馈的输入端口以电压形式求和，并联反馈的输入端口以电流形式求和</li>
<li>是电流反馈还是电压反馈由反馈网络的输入端口在放大电路的输出端口取样的对象来决定</li>
<li>直接判断是电压反馈还是电流反馈比较困难，所以使用输出短路法来进行判断</li>
<li>负反馈会使电路的增益下降</li>
<li>BJT的集电极与基极信号的相位是相反的，因为共射极放大电路的增益为负</li>
<li>（图8.1.5a）反馈回路是由Re1组成的，由与射极与基极一同组成了输入端口的同时，还与集电极一同组成了输出端口，所以位于射极上的Re1依然处于输出之中，从而可以将输出的一部分回送到输出</li>
<li>串联与并联看的是输入端口，（取样）电压与（取样）电流看的是输出端口</li>
<li>单纯的直流反馈主要用于稳定静态工作点，交流反馈或直流反馈用于对信号放大产生影响<h4 id="负反馈对放大电路性能的影响"><a href="#负反馈对放大电路性能的影响" class="headerlink" title="负反馈对放大电路性能的影响"></a>负反馈对放大电路性能的影响</h4></li>
<li>引入负反馈可以稳定增益。反馈的组态不同，稳定的增益也不同。例如电压串联负反馈只能稳定闭环电压增益，电流串联负反馈只能稳定闭环互导增益</li>
<li>负反馈只能减小反馈环内产生的失真</li>
<li>只有在放大电路的带宽可以近似为上限频率并且只有一个上限转折频率的情况下，增益带宽积为常数的结论才成立<h4 id="负反馈放大电路的稳定性"><a href="#负反馈放大电路的稳定性" class="headerlink" title="负反馈放大电路的稳定性"></a>负反馈放大电路的稳定性</h4></li>
<li>在没有任何输入信号的情况下，放大电路的输出端仍会连续不断地产生某种频率和幅度的输出信号。这种现象就是自激振荡<h2 id="第十章-信号处理与信号产生电路"><a href="#第十章-信号处理与信号产生电路" class="headerlink" title="第十章 信号处理与信号产生电路"></a>第十章 信号处理与信号产生电路</h2><h4 id="高阶有源滤波器"><a href="#高阶有源滤波器" class="headerlink" title="高阶有源滤波器"></a>高阶有源滤波器</h4></li>
<li>滤波特性取决于传递函数，不同的电路可以有相同的传递函数<h4 id="正弦波震荡电路"><a href="#正弦波震荡电路" class="headerlink" title="正弦波震荡电路"></a>正弦波震荡电路</h4></li>
<li>如果希望w0的正弦波震荡输出，就只能允许w0的正弦波既满足振幅平衡条件又满足相位条件。所以需要选频网络</li>
<li>自激振荡的信号源头是电路中的噪声等，他们的频率分布很广，其中必然包含频率为wo的信号，选频网络将他选出，在环路中形成正反馈。但是他的幅值很小，不能满足要求，所以必须对他进行放大，这个过程称为起振，在这个过程中，需要AF绝对值大于一，从而对信号进行放大，放大到一定程度后，进行稳幅，使得AF稳定为1。所以振荡电路应该包括选频——起振——稳幅环节。所以振荡电路就会由以下部分组成：放大、正反馈、选频和稳幅<h4 id="电压比较器"><a href="#电压比较器" class="headerlink" title="电压比较器"></a>电压比较器</h4></li>
<li>如果是同向输入，传输曲线向一三方向延伸，如果是反向输入，传输曲线向二四方向延伸</li>
<li>在反向迟滞比较器中，只要输入大于上门限，输出就为低电平；只要输入小于下门限，输出就为高电平。同向迟滞比较器与之刚好相反</li>
<li>输入介于上下门限之间时，输出不变</li>
</ul>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP零碎知识点整理</title>
    <url>/2020/01/30/CSP%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>摘要：</p>
<p>祝看过这篇博文的同学CSP都能考到300以上(￣▽￣)~*</p>
<p>笔记里面主要记录的是我在准备CSP过程中遇到过得问题或者学习到的新知识，涵盖C语言、C++、算法等方面内容，由于我是遇到啥写啥，所以内容有点散，不过还是希望所有读过的同学都能有所收获~</p>
<a id="more"></a>

<ul>
<li>判断整数是奇数还是偶数时，可以让这个数与1进行按位与，即num&amp;1，如果结果为1，则num为奇数，否则为偶数</li>
<li>进行整数向浮点数的转换时，可以乘以1.0</li>
<li>C++ vector容器浅析 <a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a><br>删除指定元素可以这样做： 删除第二个元素 (vec[1])<br>vec.erase(vec.begin() + 1);</li>
<li>C++ list总结 <a href="https://www.cnblogs.com/loleina/p/5179677.html" target="_blank" rel="noopener">https://www.cnblogs.com/loleina/p/5179677.html</a></li>
<li>C++ set成员函数用法总结 <a href="https://blog.csdn.net/qq_34243930/article/details/81481929" target="_blank" rel="noopener">https://blog.csdn.net/qq_34243930/article/details/81481929</a><br>set中的元素可以是pair，排序时，先按照first排序，相同的话再按照second排序。元素为pair时，set的find函数就不太好用了，这时可以使用upper_bound函数或者lower_bound()函数，函数中的比较规则也是先看first再看second。lower_bound()函数返回的是第一个不小于给定元素key的位置，upper_bound() 函数返回的是第一个大于给定元素key的位置。<br>例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set&lt;pair&lt;int, int&gt; &gt; st;</span><br><span class="line">set&lt;pair&lt;int, int&gt; &gt;::iterator st_it;</span><br><span class="line">st.insert(make_pair(2, 6));</span><br><span class="line">st.insert(make_pair(1, 5)); </span><br><span class="line">st.insert(make_pair(3, 7));       </span><br><span class="line">st.insert(make_pair(4, 8));</span><br><span class="line">cout &lt;&lt; &quot;遍历输出&quot; &lt;&lt; endl;</span><br><span class="line">for(st_it &#x3D; st.begin(); st_it !&#x3D; st.end(); st_it++)&#123;</span><br><span class="line">    cout &lt;&lt; st_it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">st_it &#x3D; st.lower_bound(make_pair(3, 7));</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; &quot;查找输出&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; st_it-&gt;second;</span><br></pre></td></tr></table></figure></li>
<li>C++ map的基本操作和使用 <a href="https://blog.csdn.net/qq_40914533/article/details/81981467" target="_blank" rel="noopener">https://blog.csdn.net/qq_40914533/article/details/81981467</a></li>
<li>qsort()函数 <a href="https://www.runoob.com/cprogramming/c-function-qsort.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-function-qsort.html</a></li>
<li>C++ sort()函数 <a href="https://www.cnblogs.com/TX980502/p/8528840.html" target="_blank" rel="noopener">https://www.cnblogs.com/TX980502/p/8528840.html</a><br>sort和qsort之间更推荐sort<br>概述：需要头文件<algorithm><br>语法描述：sort（begin，end，cmp），cmp参数可以没有，如果没有默认非降序排序，end为最后一个元素再后面一个位置的指针<br>对于cmp函数的编写，如果return a&gt;b; 则理解为使用&gt;号对元素进行排序。<br>其实对于这么简单的任务（类型支持“&lt;”、“&gt;”等比较运算符），完全没必要自己写一个类出来。标准库里已经有现成的了，就在functional里，include进来就行了。functional提供了一堆基于模板的比较函数对象。它们是（看名字就知道意思了）：equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>。对于这个问题来说，greater和less就足够了，直接拿过来用：<br>升序：sort(begin,end,less<data-type>());<br>降序：sort(begin,end,greater<data-type>()).<br>详见文中：字符串内的字符排序、字符串之间排序、结构体的二级排序</li>
<li>C++ 运算符的重载 <a href="https://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-overloading.html</a></li>
<li>C++ 关系运算符的重载 <a href="https://www.runoob.com/cplusplus/relational-operators-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/relational-operators-overloading.html</a></li>
<li>C++ 优先队列priority_queue用法详解 <a href="https://blog.csdn.net/weixin_36888577/article/details/79937886" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36888577/article/details/79937886</a><br>优先队列中的内容默认是从大到小</li>
<li>一个函数实现16进制的数字与字符之间的转换：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;关键在于形参是char类型</span><br><span class="line">char getc(char c)&#123;   </span><br><span class="line">    if(c&lt;10)   </span><br><span class="line">        return c+&#39;0&#39;;   </span><br><span class="line">    else if(c&lt;&#x3D;16)   </span><br><span class="line">        return c+&#39;A&#39;-10;   </span><br><span class="line">    else if(c&lt;&#x3D;&#39;9&#39;)   </span><br><span class="line">        return c-&#39;0&#39;;   </span><br><span class="line">    else if(c&lt;&#x3D;&#39;F&#39;)   </span><br><span class="line">        return c-&#39;A&#39;+10;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对两个字符进行异或可以使用这个函数：ret=getc(getc(a[i])^getc(b[i]));先将字符转换为整数，进行异或之后再转换回字符</li>
<li>可以用宏来定义for循环，简化代码：#define UP(x) for(uint32_t i=0;i&lt;x;i++)   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UP(8)&#123;</span><br><span class="line">        a[i]&#x3D;getc(getc(a[i])^getc(b[i]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>C++ 引用：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br>引用很容易与指针混淆，它们之间有三个主要的不同：   <ul>
<li>不存在空引用。引用必须连接到一块合法的内存。   </li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。   </li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化</li>
</ul>
</li>
<li>C++  把引用作为返回值 <a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/returning-values-by-reference.html</a></li>
<li>C++ 把引用作为参数 <a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/passing-parameters-by-references.html</a></li>
<li>namespace以及using的用法 <a href="https://www.runoob.com/cplusplus/cpp-namespaces.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-namespaces.html</a></li>
<li>C++ cout：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::showpoint);  &#x2F;&#x2F; 设左对齐，以一般实数方式显示</span><br><span class="line">    cout.precision(5);       &#x2F;&#x2F; 设置除小数点外有五位有效数字 </span><br><span class="line">    cout&lt;&lt;123.456789&lt;&lt;endl;</span><br><span class="line">    cout.width(10);          &#x2F;&#x2F; 设置显示域宽10 </span><br><span class="line">    cout.fill(&#39;*&#39;);          &#x2F;&#x2F; 在显示区域空白处用*填充</span><br><span class="line">    cout&lt;&lt;resetiosflags(ios::left);  &#x2F;&#x2F; 清除状态左对齐</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::right);   &#x2F;&#x2F; 设置右对齐</span><br><span class="line">    cout&lt;&lt;123.456789&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::fixed);    &#x2F;&#x2F; 设左对齐，以固定小数位显示</span><br><span class="line">    cout.precision(3);    &#x2F;&#x2F; 设置实数显示三位小数</span><br><span class="line">    cout&lt;&lt;999.123456&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;resetiosflags(ios::left|ios::fixed);  &#x2F;&#x2F;清除状态左对齐和定点格式</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::scientific);    &#x2F;&#x2F;设置左对齐，以科学技术法显示 </span><br><span class="line">    cout.precision(3);   &#x2F;&#x2F;设置保留三位小数</span><br><span class="line">    cout&lt;&lt;123.45678&lt;&lt;endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果为：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123.46</span><br><span class="line">****123.46</span><br><span class="line">999.123</span><br><span class="line">1.235e+02</span><br></pre></td></tr></table></figure>
setiosflags中的常见标志：<br>boolalpha    可以使用单词”true”和”false”进行输入/输出的布尔值.<br>oct    用八进制格式显示数值.<br>dec    用十进制格式显示数值.<br>hex    用十六进制格式显示数值.<br>left    输出调整为左对齐.<br>right    输出调整为右对齐.<br>scientific    用科学记数法显示浮点数.<br>fixed    用正常的记数方法显示浮点数(与科学计数法相对应).<br>showbase    输出时显示所有数值的基数.<br>showpoint    显示小数点和额外的零，即使不需要.<br>showpos    在非负数值前面显示”＋（正号）”.<br>skipws    当从一个流进行读取时，跳过空白字符(spaces, tabs, newlines).<br>unitbuf    在每次插入以后，清空缓冲区.<br>internal    将填充字符回到符号和数值之间.<br>uppercase    以大写的形式显示科学记数法中的”e”和十六进制格式的”x”.   </li>
<li><strong>C++</strong> 输入：<ul>
<li>cin<br>输入时，以空格、tab、回车作为分隔符。当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，<strong>cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&gt;&gt;不做处理</strong></li>
<li>cin.getline()<br>用于读取字符串，读到的字符串是c++风格的string类型。<br>cin.getline默认读取到回车时终止，并将回车符号转换为\0存入字符串，同时将回车符从缓冲区中删除。空格也会被读取<br>函数原型有两个：   </li>
</ul>
</li>
</ul>
<p><em>//s是存放读取到的字符串的数组，count是读取长度<br>istream&amp; getline(char</em> s, streamsize count); //默认以换行符结束<br>istream&amp; getline(char* s, streamsize count, char delim);//delim为规定的结束符*   </p>
<ul>
<li>getline()<br>getline(cin, str)与cin.getline(str, num)作用相同，都可以读取空格，默认以回车结束。但是cin.getline的str要求是字符数组，且必须要指定num。而getline的str是string类型的变量，而且不需要指定长度。所以推荐使用getline。</li>
<li>cin.get<br>使用cin.get读取字符串时，可以这样使用：<br>ch = cin.get();<br>cin.get(ch);<br>或者直接cin.get()表示不将输入读取到任何变量，只是用来阻塞或者清除多余回车<br>cin.get()也可以用于读取字符串，不建议使用</li>
<li>gets<br>不建议使用</li>
<li>综上所述，普通输入用cin，读取字符串用getline()，读取字符用cin.get()<ul>
<li>ios::sync_with_stdio(false)可以用来提高cin和cout的速度</li>
<li>C++ 字符串<br>Cpp提供了两种类型的字符串表示形式：一种是C风格的字符串，另一种是C++风格的string类型字符串 </li>
<li>头文件<string><cstring>之间的区别：cstring是c语言中的string.h的c++版本，用法相同，用于处理C语言形式的字符串。引用string后就可以使用string类型（其实不引用也可以使用string类型），同时可以使用下面的string类中的函数。在处理字符串时，需要注意C++与c类型的字符串之间的区别，平时尽量只使用c++类型的字符串，必要时可以使用string类中的data()或者c_str()函数将string类型的字符串转化为c类型的字符串，两种方法的不同之处是，c_str()转换后会在最后加\0，而data()不会。</li>
<li>c_str()应该这样用: char c[20]; string s=”1234”; strcpy(c,s.c_str()); 这样才不会出错,c_str()返回的是一个临时指针,不能对其进行操作</li>
<li>C++ string类   </li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/Draymonder/p/6944479.html" target="_blank" rel="noopener">https://www.cnblogs.com/Draymonder/p/6944479.html</a></li>
<li>构造函数(Constructors)<br>语法:<br>string();<br>string( size_type length, char ch );<br>string( const char *str );参数是c形式字符串，可以实现c形式字符串到c++形式字符串的转换<br>string( const char *str, size_type length );<br>string( string &amp;str, size_type index, size_type length );<br>string( input_iterator start, input_iterator end );<br>字符串的构造函数创建一个新字符串，包括:<br>以length为长度的ch的拷贝（即length个ch）<br>以str为初值 (长度任意),<br>以index为索引开始的子串，长度为length, 或者<br>以从start到end的元素为初值.<br>例如,<br>string str1( 5, ‘c’ );<br>string str2( “Now is the time…” );<br>string str3( str2, 11, 4 );<br>cout &lt;&lt; str1 &lt;&lt; endl;<br>cout &lt;&lt; str2 &lt;&lt; endl;<br>cout &lt;&lt; str3 &lt;&lt; endl;<br>显示<br>ccccc<br>Now is the time…<br>time   </li>
<li>对字符串赋值方法很多，例如：<br>string s1(“hello”), s2;<br>s2 = s1;<br>或者用assign函数s2.assign(s1)</li>
<li>求字符串长度可以用.length()也可以用.size()</li>
<li>除了使用+、+=来连接字符串之外，还可以用append()函数在字符串末尾添加内容</li>
<li>字符串比较可以使用&gt; &lt; &gt;= &lt;=等等，比较的不是字符串长度，而是一位一位地比较字母的大小。<ul>
<li>201709_2：需要进行多重排序时，可以将排序依据包装到一个结构体里面，然后编写cmp函数，利用sort函数进行排序</li>
<li>什么是标准模板库（STL）？<br>(1)C++标准模板库与C++标准库的关系<br>C++标准模板库其实属于C++标准库的一部分，C++标准模板库主要是定义了标准模板的定义与声明，而这些模板主要都是<br>类模板，我们可以调用这些模板来定义一个具体的类；与之前的自己手动创建一个函数模版或者是类模板不一样，我们使用了<br>STL就不用自己来创建模板了，这些模板都定义在标准模板库中，我们只需要学会怎么使用这些类模板来定义一个具体的类，<br>然后能够使用类提供的各种方法来处理数据。<br>(2)STL六大组件：容器（containers）、算法（algorithms）、迭代器（iterators）、函数对象（functors）、适配器（adapters）、分配器（allocators）</li>
<li>在C++中，结构体可以有构造函数。例如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ROLE&#123;</span><br><span class="line">    int health;</span><br><span class="line">    int attack;</span><br><span class="line">    ROLE()&#123;health &#x3D; 0; attack &#x3D; -1;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int r,c,dist;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(int r,int c,int dist):r(r),c(c),dist(dist)&#123;&#125;&#x2F;&#x2F;r(r)表示将r赋值给变量r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在C++中，定义结构体时不需要使用typedef，创建一个新的结构体变量的时候也不需要再加上struct，直接使用结构体的名字即可。例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct A &#123; &#x2F;&#x2F; 声明结构体</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a_st;  &#x2F;&#x2F;定义结构体</span><br><span class="line">A* a_p; &#x2F;&#x2F; 定义结构体指针</span><br></pre></td></tr></table></figure></li>
<li>使用#ifdef提高效率，例如<br>int main()<br>{<br>#ifdef LOCAL<br>freopen(“datain.txt”,”r”,stdin);<br>#endif // LOCAL<br>run();<br>ans();<br>return 0;<br>}<br>如果在前面已经有#define LOCAL，那么就会执行freopen，否则就直接执行endif后面的语句。在本地测试时，要在前面加上#define LOCAL，这样只需要将测试用例写到datain.txt中，不需要每次都手动输入。提交时，将#define LOCAL删除。</li>
<li>使用stringstream进行数据转换（int-&gt;string）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    std::string result;</span><br><span class="line">    int i &#x3D; 1000;</span><br><span class="line">    stream &lt;&lt; i; &#x2F;&#x2F;将int输入流</span><br><span class="line">    stream &gt;&gt; result; &#x2F;&#x2F;从stream中抽取前面插入的int值</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; &#x2F;&#x2F; print the string &quot;1000&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stringstream进行数据类型转换(int-&gt;char*)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    char result[8] ;</span><br><span class="line">    stream &lt;&lt; 8888; &#x2F;&#x2F;向stream中插入8888</span><br><span class="line">    stream &gt;&gt; result; &#x2F;&#x2F;抽取stream中的值到result</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; &#x2F;&#x2F; 屏幕显示 &quot;8888&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stringstream进行数据类型转换()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃i nclude &lt;iostream&gt; </span><br><span class="line">＃i nclude &lt;sstream&gt; </span><br><span class="line">＃i nclude &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">stringstream sstr; </span><br><span class="line">string name &#x3D; &quot;colinguan&quot;; </span><br><span class="line">char cname[200]; </span><br><span class="line">sstr&lt;&lt;name; </span><br><span class="line">sstr&gt;&gt;cname; </span><br><span class="line">cout&lt;&lt;cname; </span><br><span class="line">system(&quot;pause&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重复使用同一个stringstream进行数据转换时，必须调用其成员函数clear()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    int first, second;</span><br><span class="line">    stream&lt;&lt; &quot;456&quot;; &#x2F;&#x2F;插入字符串</span><br><span class="line">    stream &gt;&gt; first; &#x2F;&#x2F;转换成int</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; std::endl;</span><br><span class="line">    stream.clear(); &#x2F;&#x2F;在进行多次转换前，必须清除stream</span><br><span class="line">    stream &lt;&lt; true; &#x2F;&#x2F;插入bool值</span><br><span class="line">    stream &gt;&gt; second; &#x2F;&#x2F;提取出int</span><br><span class="line">    std::cout &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>stringstream有两种构造函数，一种是没有任何参数；另一种是带有参数。带有参数时，其参数将直接成为构造的stringstream对象的内容。另外，stringstream类还有一个成员函数put()。用于向stringstream中添加内容。当使用没有参数的方法构造stringstream时，使用put()函数则直接向stringstream尾部添加。使用带参数的方式时，使用put()函数就会从覆盖之前的内容。例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;sstream&gt; </span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">string cc &#x3D; &quot;ccc&quot;;</span><br><span class="line">stringstream ostr;</span><br><span class="line">ostr &lt;&lt; cc;</span><br><span class="line">ostr.put(&#39;d&#39;); </span><br><span class="line">ostr.put(&#39;e&#39;); </span><br><span class="line">ostr&lt;&lt;&quot;fg&quot;; </span><br><span class="line">string gstr &#x3D; ostr.str(); </span><br><span class="line">cout&lt;&lt;gstr&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">char a; </span><br><span class="line">ostr&gt;&gt;a; </span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;cccdefg</span><br><span class="line">&#x2F;&#x2F;c</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;sstream&gt; </span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">stringstream ostr(&quot;ccc&quot;);</span><br><span class="line">ostr.put(&#39;d&#39;); </span><br><span class="line">ostr.put(&#39;e&#39;); </span><br><span class="line">ostr&lt;&lt;&quot;fg&quot;; </span><br><span class="line">string gstr &#x3D; ostr.str(); </span><br><span class="line">cout&lt;&lt;gstr&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">char a; </span><br><span class="line">ostr&gt;&gt;a; </span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;defg</span><br><span class="line">&#x2F;&#x2F;d</span><br></pre></td></tr></table></figure></li>
<li>广度优先搜索模版<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BFS(int s)&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        取出队首元素top;</span><br><span class="line">        访问队首元素top;&#x2F;&#x2F;（访问可以是任何操作，例如打印输出）</span><br><span class="line">        将队首元素出队;</span><br><span class="line">        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个BFS的例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*问题描述：给出一个m*n的矩阵，矩阵中的元素为0或1，称位置（x，y）与其上下左右</span><br><span class="line">四个位置是相邻的，如果矩阵中有若干个1是相邻的（不必两两相邻），那么称这些1构成一个块。求给定矩阵中块的个数</span><br><span class="line">*&#x2F; </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define LOCAL</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int matrix[maxn][maxn];</span><br><span class="line">bool inq[maxn][maxn];</span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool judge(int x, int y)&#123;</span><br><span class="line">	if(x&gt;&#x3D;n || x&lt;0 || y&gt;&#x3D;m || y&lt;0)</span><br><span class="line">		return false;</span><br><span class="line">	if(matrix[x][y] &#x3D;&#x3D; 0 || inq[x][y] &#x3D;&#x3D; true)</span><br><span class="line">		return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;bool inq[maxn][maxn] &#x3D; &#123;false&#125;;</span><br><span class="line">	#ifdef LOCAL</span><br><span class="line">	freopen(&quot;data.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	#endif</span><br><span class="line">	int i, j, k, newx, newy, cnt&#x3D;0;</span><br><span class="line">	Node node;</span><br><span class="line">	queue&lt;Node&gt; q;</span><br><span class="line">	int plusx[4] &#x3D; &#123;0, 0, 1, -1&#125;;</span><br><span class="line">	int plusy[4] &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cin.get();</span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		for(j&#x3D;0; j&lt;m; j++)&#123;</span><br><span class="line">			cin &gt;&gt; matrix[i][j];</span><br><span class="line">			cin.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		for(j&#x3D;0; j&lt;m; j++)&#123;</span><br><span class="line">			if(judge(i, j))&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				node.x &#x3D; i;</span><br><span class="line">				node.y &#x3D; j;</span><br><span class="line">				q.push(node);</span><br><span class="line">				while(!q.empty())&#123;</span><br><span class="line">					Node top &#x3D; q.front();</span><br><span class="line">					q.pop();</span><br><span class="line">					for(k&#x3D;0; k&lt;4; k++)&#123;</span><br><span class="line">						newx &#x3D; top.x + plusx[k];</span><br><span class="line">						newy &#x3D; top.y + plusy[k];</span><br><span class="line">						node.x &#x3D; newx;</span><br><span class="line">						node.y &#x3D; newy;</span><br><span class="line">						if(judge(newx, newy))&#123;</span><br><span class="line">							q.push(node);</span><br><span class="line">							inq[node.x][node.y] &#x3D; true;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个DFS的例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*问题描述：有n件物品，每件物品的重量为w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为v的包中，使得在选入背包的物品不超过容量的情况下，让背包中物品的总价值最大，求最大价值</span><br><span class="line">*&#x2F;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define LOCAL</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line"></span><br><span class="line">int n, v;</span><br><span class="line">int maxvalue &#x3D; 0;</span><br><span class="line">int w[maxn];</span><br><span class="line">int c[maxn];</span><br><span class="line">void DFS(int index, int sumw, int sumc)&#123;</span><br><span class="line">	if(index &#x3D;&#x3D; n)&#123;</span><br><span class="line">		if(sumw &lt;&#x3D; v &amp;&amp; sumc &gt; maxvalue)&#123;</span><br><span class="line">			maxvalue &#x3D; sumc;</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(index+1, sumw, sumc);</span><br><span class="line">	DFS(index+1, sumw+w[index], sumc+c[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	#ifdef LOCAL</span><br><span class="line">	freopen(&quot;data_DFS.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	#endif</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">	cin.get();</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; w[i];</span><br><span class="line">		cin.get();</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; c[i];</span><br><span class="line">		cin.get();</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(0, 0, 0);</span><br><span class="line">	cout &lt;&lt; maxvalue;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>fill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(vec.begin(), vec.end(), val); val为将要替换的值。需要头文件<algorithm></li>
</ul>
</li>
</ul>
<ul>
<li><p>使用nullptr来代替NULL</p>
</li>
<li><p>关于new和malloc</p>
<ul>
<li>申请内存时的位置可能会不同</li>
<li>使用new时会对对象进行初始化，例如申请了一个结构体的空间，会对结构体中的变量进行初始化。如果结构体中有string变量，但是使用的是malloc的话，会因为没有给string进行初始化而bomb</li>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型</li>
<li>C++提供了new[]与delete[]来专门处理数组类型:<br>A * ptr = new A[10];//分配10个A对象<br>使用new[]分配的内存必须使用delete[]进行释放：<br>delete [] ptr<br>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</li>
<li>使用new申请的空间，使用delete进行释放</li>
<li>特别大的数组不要在函数里面开，有可能会栈溢出。可以定义成全局变量。</li>
</ul>
</li>
<li><p>tarjan算法</p>
<p>tarjan算法用来求图中的强连通分量。tarjan算法是基于DFS算法的，会给每个访问的节点一个时间戳，时间戳存在DFN[]数组里面，同时还要记录每个节点的能回溯到的最早访问的节点的时间戳，这些存在low[]数组中。当访问到某一个节点i，有DFN[i] == low[i]时，便找到了一个新的强连通分量。</p>
<p>tarjan算法模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5010<span class="comment">//题目中可能的最大点数</span></span></span><br><span class="line"><span class="keyword">int</span> STACK[M],top=<span class="number">0</span>;<span class="comment">//Tarjan算法中的栈</span></span><br><span class="line"><span class="keyword">bool</span> InStack[M];<span class="comment">//检查是否在栈中</span></span><br><span class="line"><span class="keyword">int</span> DFN[M] = &#123;<span class="number">0</span>&#125;;<span class="comment">//深度优先搜索访问次序</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Low[M];<span class="comment">//能追溯到的最早的次序</span></span><br><span class="line"><span class="keyword">int</span> ComponentNumber=<span class="number">0</span>;<span class="comment">//有向图强连通分量个数</span></span><br><span class="line"><span class="keyword">int</span> Index=<span class="number">0</span>;<span class="comment">//索引号</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Edge[M];<span class="comment">//邻接表表示</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Component[M];<span class="comment">//获得强连通分量结果</span></span><br><span class="line"><span class="keyword">int</span> InComponent[M];<span class="comment">//记录每个点在第几号强连通分量里</span></span><br><span class="line"><span class="keyword">int</span> ComponentDegree[M];<span class="comment">//记录每个强连通分量的度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    DFN[i]=Low[i]=++Index;</span><br><span class="line">    InStack[i]=<span class="literal">true</span>;STACK[++top]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e=<span class="number">0</span>;e&lt;Edge[i].size();e++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=Edge[i][e];</span><br><span class="line">        <span class="keyword">if</span> (DFN[j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(j);</span><br><span class="line">            Low[i]=min(Low[i],Low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (InStack[j]) Low[i]=min(Low[i],DFN[j]);<span class="comment">//也可Low[i]=min(Low[i],Low[j]);仅限在求强联通分量时</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DFN[i]==Low[i])</span><br><span class="line">    &#123;</span><br><span class="line">        ComponentNumber++;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            j=STACK[top--];</span><br><span class="line">            InStack[j]=<span class="literal">false</span>;</span><br><span class="line">            Component[ComponentNumber].push_back(j);</span><br><span class="line">            InComponent[j]=ComponentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j!=i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
