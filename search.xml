<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>csp 201604_2 俄罗斯方块</title>
    <url>/2020/02/17/csp-201604-2-%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    <content><![CDATA[<p>摘要：</p>
<p>注意细节！注意审题！</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。<br>　　游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。<br>　　在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。<br>　　具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。<br>　　输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。<br>　　第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 1 0 0<br>0 0 0 0 0 0 1 0 0 0<br>0 0 0 0 0 0 1 0 0 0<br>1 1 1 0 0 0 1 1 1 1<br>0 0 0 0 1 0 0 0 0 0<br>0 0 0 0<br>0 1 1 1<br>0 0 0 1<br>0 0 0 0<br>3</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 1 0 0<br>0 0 0 0 0 0 1 0 0 0<br>0 0 0 0 0 0 1 0 0 0<br>1 1 1 1 1 1 1 1 1 1<br>0 0 0 0 1 1 0 0 0 0</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">15</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> block[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;<span class="comment">//四个方块的坐标</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; col;</span><br><span class="line"><span class="keyword">int</span> icol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        freopen(<span class="string">"201604_2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> dline=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; block[i][j];</span><br><span class="line">            <span class="keyword">if</span>(block[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                line.push_back(i);</span><br><span class="line">                col.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; icol;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">map</span>[dline+line[<span class="number">0</span>]+<span class="number">1</span>][col[<span class="number">0</span>]+icol<span class="number">-1</span>]^block[line[<span class="number">0</span>]][col[<span class="number">0</span>]] &amp;&amp; <span class="built_in">map</span>[dline+line[<span class="number">1</span>]+<span class="number">1</span>][col[<span class="number">1</span>]+icol<span class="number">-1</span>]^block[line[<span class="number">1</span>]][col[<span class="number">1</span>]] &amp;&amp; <span class="built_in">map</span>[dline+line[<span class="number">2</span>]+<span class="number">1</span>][col[<span class="number">2</span>]+icol<span class="number">-1</span>]^block[line[<span class="number">2</span>]][col[<span class="number">2</span>]] &amp;&amp; <span class="built_in">map</span>[dline+line[<span class="number">3</span>]+<span class="number">1</span>][col[<span class="number">3</span>]+icol<span class="number">-1</span>]^block[line[<span class="number">3</span>]][col[<span class="number">3</span>]])&#123;</span><br><span class="line">        dline++;</span><br><span class="line">        <span class="keyword">if</span>(dline+line[<span class="number">0</span>]==<span class="number">14</span> || dline+line[<span class="number">1</span>]==<span class="number">14</span> || dline+line[<span class="number">2</span>]==<span class="number">14</span> || dline+line[<span class="number">3</span>]==<span class="number">14</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">map</span>[dline+line[i]][col[i]+icol<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">map</span>[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">9</span>) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题思路不难，但是0分了好久才最后AC，原因在于我一开始输出的时候没有注意到所有的数字需要用空格隔开，修复了这个bug之后马上就AC了，这种情况如果出现在真正的考试中绝对血亏，相当于白给100分，之后在做题过程中一定要注意，审清题目，看好输出的格式和要求。</p>
]]></content>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu下qt环境配置</title>
    <url>/2020/02/11/ubuntu%E4%B8%8Bqt%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>摘要：</p>
<p>第一次使用qt，亲自踩坑整理出来的，记录一下</p>
<a id="more"></a>

<h2 id="下载QT"><a href="#下载QT" class="headerlink" title="下载QT"></a>下载QT</h2><p>点击<a href="https://download.qt.io/archive/qt/" target="_blank" rel="noopener">这里</a>下载即可，我下载的是qt-opensource-linux-x64-5.7.1.run。</p>
<p>下载下来之后运行安装即可，QT库和QT creator都会被安装。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如果我们不进行配置，直接新建一个工程来运行的话，我这边会报错说“Error while building/deploying project XXX when executing step ‘qmake’”。我分析的原因有两个，一个是ubuntu系统本身自带qt库，我们还没有指定qt creator去使用我们新安装的qt库；另一个原因是我们还没有配置qmake的路径，qt creator找不到qmake。解决方法如下。</p>
<ol>
<li><p>首先打开终端输入下面的指令安装qtchooser</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install qtchooser</span><br></pre></td></tr></table></figure>

<p>安装它是因为我们希望借助这个工具来指定我们当前想要使用的qt版本。</p>
</li>
<li><p>增加我们新下载的那个qt环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qtchooser -install qt5.7 &#x2F;home&#x2F;zhangyazhe&#x2F;Qt5.7.1&#x2F;5.7&#x2F;gcc_64&#x2F;bin&#x2F;qmake</span><br></pre></td></tr></table></figure>

<p>qt5.7是这个环境的name，可以随意起。后面的路径是qmake的路径。</p>
</li>
<li><p>设置下环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export QT_SELECT&#x3D;qt5.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>经过上面的操作，qmake就配置好了，可以执行qmake -v来查看版本。这个时候再运行工程，不会再显示qmake出错，而是开始显示make出错，这时候执行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libqt4-dev</span><br></pre></td></tr></table></figure>

<p>之后再尝试运行就ok了。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201503_4 网络延迟</title>
    <url>/2020/02/09/csp-201503-4-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F/</url>
    <content><![CDATA[<p>摘要：</p>
<p>树的直径 dfs</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定一个公司的网络，由<em>n</em>台交换机和<em>m</em>台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。<br>　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示交换机的台数和终端电脑的台数。<br>　　第二行包含<em>n</em> - 1个整数，分别表示第2、3、……、<em>n</em>台交换机所连接的比自己上一层的交换机的编号。第<em>i</em>台交换机所连接的上一层的交换机编号一定比自己的编号小。<br>　　第三行包含<em>m</em>个整数，分别表示第1、2、……、<em>m</em>台终端电脑所连接的交换机的编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示消息传递最多需要的步数。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>4 2<br>1 1 3<br>2 1</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>4</p>
<h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><p>4 4<br>1 2 2<br>3 4 4 4</p>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><p>4</p>
<h3 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h3><p>电脑1与电脑4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　前30%的评测用例满足：<em>n</em> ≤ 5, <em>m</em> ≤ 5。<br>　　前50%的评测用例满足：<em>n</em> ≤ 20, <em>m</em> ≤ 20。<br>　　前70%的评测用例满足：<em>n</em> ≤ 100, <em>m</em> ≤ 100。<br>　　所有评测用例都满足：1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 10000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是经典的求树的直径的问题，这种问题一般有两种解法，一种是dfs一种是dp，我使用的是dfs的方法。树的直径有一个性质：对于树中的任意一个结点，找到距离它最远的那个点，记为点u。再寻找树中距离点u最远的那个点，记为点v，那么点u与点v之间的距离，即为树的直径。这个性质在这里不再证明，网上可以查到证明过程。有了这个性质，我们的思路就是，先随便找一个点进行dfs，找到距离这个点最远的点u，再从u开始dfs找到树的直径。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>; <span class="comment">//因为n m 相加需要20000</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> maxCost,number;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</span><br><span class="line">        G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>; <span class="comment">//是否通过</span></span><br><span class="line">    <span class="keyword">if</span>(maxCost&lt;cost)</span><br><span class="line">    &#123;</span><br><span class="line">        maxCost=cost; <span class="comment">//记录最长路径距离 因为有回溯所以需要全局变量</span></span><br><span class="line">        number=u;  <span class="comment">//记录最长距离的最后一个点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[u].size(); i++) <span class="comment">//对U的每一个邻接点遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[G[u][i]])  <span class="comment">//若该邻接点未标记，则距离加1，继续递归调用</span></span><br><span class="line">            dfs(G[u][i],cost+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,x,i;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n+m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        G[i].push_back(x);<span class="comment">//第i个的前一个  机器顺延交换机顺序</span></span><br><span class="line">        G[x].push_back(i);<span class="comment">//无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxCost=<span class="number">-1</span>;  <span class="comment">//每次调用dfs函数时，首先要对最大值初始化为-1，且vis初始化为0</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//访问变量初始化</span></span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    maxCost=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dfs(number,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxCost&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>通过编译linux内核增加具有拷贝功能的系统调用</title>
    <url>/2020/02/08/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8%E5%A2%9E%E5%8A%A0%E5%85%B7%E6%9C%89%E6%8B%B7%E8%B4%9D%E5%8A%9F%E8%83%BD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>摘要：</p>
<p>通过编译linux内核的方式，增加一个新的系统调用。另外编写一个应用程序来测试和使用新增加的系统调用。其中，新增加的系统调用具有文件拷贝功能。</p>
<a id="more"></a>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>我们都知道，很多我们习以为常的C语言标准函数，在linux平台的实现都是通过系统调用完成的，例如我们在用户程序中使用open()或者write()函数时，函数执行过程中会通过中断进入到系统内核中，在Intel CPU中，这个由中断INT0x80实现。跳转到的内核位置叫做sysem_call。检查系统调用号，这个号码代表进程请求哪种服务。然后，它查看系统调用表(sys_call_table)找到所调用的内核函数入口地址。接着，就调用内核函数来实现open()或者write()等函数的功能。我们要做的，就是在内核中增加一个内核函数，相应地也在系统调用表中增加一个表项，使得我们增加的功能永远的留存在系统中。</p>
<h2 id="系统说明"><a href="#系统说明" class="headerlink" title="系统说明"></a>系统说明</h2><p>我使用的是电脑是macbook pro，做这个实验用的是vmware中的ubuntu18.04.3虚拟机。</p>
<h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>首先我们要进行一些准备工作，安装相关依赖。打开终端输入下列命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libncurses5-dev libssl-dev</span><br><span class="line">sudo apt-get install build-essential openssl</span><br><span class="line">sudo apt-get install zlibc minizip</span><br><span class="line">sudo apt-get install libidn11-dev libidn11</span><br><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install flex</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Snoopy是个小机灵」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;snoopy19981210&#x2F;article&#x2F;details&#x2F;89957254</span><br></pre></td></tr></table></figure>

<p>之后，我们并不会直接编译我们现在使用的ubuntu的linux内核，因为有可能会把系统搞崩代价太大，所以采取的方法是单独下载一个linux内核，我是从<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" target="_blank" rel="noopener">清华的镜像网站</a>下载的，下载的linux内核版本为4.18.3。</p>
<p>下载之后会得到一个压缩包，解压。</p>
<p>之后用<strong>sudo mv linux-4.18.3 /usr/src</strong>命令，将该文件夹移动至/usr/src。</p>
<p>然后找到/usr/src/linux-4.18.3/arch/x86/entry/syscalls/syscall_64.tbl，我的理解是，syscall_64.tbl就是系统调用表，程序运行时，内核会通过这个表找到系统调用程序的位置。我们打开这个文件，可以看到每行第一列都有一个编号，第三列是系统调用的名字。我们在编号为334的一行后面新加一行，编号为335，第二列为common，第三列为新增系统调用的名字，我命名为mycall，第四列为__x64_sys_mycall。</p>
<p>之后找到/usr/src/linux-4.18.3/include/linux/syscalls.h，从文件名字就能看出来，这里面的都是函数的声明，我们在文件的最后，#endif之前，添加我们自定义的函数的声明.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asmlinkage long sys_mycall(char *src, char *dest);</span><br></pre></td></tr></table></figure>

<p>最前面的asmlinkage表示函数参数将存放在局部栈中，系统调用大多都采取这种方式。然后因为我们要实现的是文件拷贝功能，所以参数列表中是源文件的文件名和目标文件的文件名。</p>
<p>之后，找到/usr/src/linux-4.18.3/kernel/sys.c，我们将新增加的函数的定义添加在文件的末尾，#endif之前。</p>
<p>接下来需要重点说一下函数定义该怎么写，即拷贝系统调用如何实现。</p>
<p>首先需要注意的是，在内核中，我们只能使用内核函数，比如open()、write()函数都不能用了，需要用ksys_open()和ksys_write()。</p>
<p>ksys_open()函数的原型为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">ksys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>flags定义文件打开方式，O_RDONLY表示以只读方式打开，O_WRONLY表示可读可写方式打开，O_CREAT表示要打开的文件不存在时自动创建文件。</p>
<p>mode定义权限，S_IRUSR表示允许用户读文件，S_IWUSR表示允许用户写文件。</p>
<p>下面的函数名和参数列表肯定会让你疑惑，往下看，代码后面会解释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE2(mycall,<span class="keyword">char</span> *,src,<span class="keyword">char</span> *,dest)&#123;</span><br><span class="line">	<span class="keyword">int</span> fs,fd,len;</span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">mm_segment_t</span> fss;</span><br><span class="line"> 	fss = get_fs();</span><br><span class="line"> 	set_fs(KERNEL_DS);</span><br><span class="line">	fs=ksys_open(src,O_RDONLY,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(fs==<span class="number">-1</span>)&#123;</span><br><span class="line">		printk(<span class="string">"source file error,maybe it doesn't exist.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fd=ksys_open(dest,O_CREAT|O_WRONLY|O_TRUNC,S_IRUSR|S_IWUSR);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		printk(<span class="string">"fail to create destination.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>((len=ksys_read(fs,<span class="built_in">buffer</span>,<span class="number">50</span>))&gt;<span class="number">0</span>)</span><br><span class="line">		ksys_write(fd,<span class="built_in">buffer</span>,len);</span><br><span class="line">	ksys_close(fs);</span><br><span class="line">	ksys_close(fd);</span><br><span class="line">	set_fs(fss);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，函数名我们用的是SYSCALL_DEFINE2，并且本来应该是参数应该是char * sourceFile，却被我写成了char *, sourceFile，打开sys.c文件我们会发现，许多函数都是这样写的，如果不想去深究，我们只需要知道2代表着参数列表中参数的个数，参数列表中变量类型与变量名之间要加逗号，如果想仔细探究下，可以参考<a href="https://blog.csdn.net/hxmhyp/article/details/22699669" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>接下来进行编译内核前的准备工作，终端输入下列指令。其中第二条指令用来清除编译过程中所有的中间文件，第三条指令用于清除上一次编译的中间文件，第三条指令用于生成.config文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;src&#x2F;linux-4.18.3</span><br><span class="line">sudo make mrproper</span><br><span class="line">sudo make clean</span><br><span class="line">sudo make menuconfig</span><br></pre></td></tr></table></figure>

<p>在出现的界面中不需要任何操作直接exit。</p>
<p>接下来开始编译内核，输入指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>

<p>输入指令后，内核就开始编译了，这个过程会比较久。如果出了错，重新编译前应该重新输入一次上面的sudo make mrproper、sudo make clean和sudo make menuconfig命令。</p>
<p>编译完成后，生成了新的内核，我们安装新生成的内核。输入指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make modules_install</span><br><span class="line">sudo make install</span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>

<p>完成之后，我们的新内核就算是编译好了，接下来进行测试。</p>
<p>重启虚拟机，启动时同时按住esc和shift，在弹出的界面选择ubuntu高级选项，选择新编译的那个内核来启动系统。</p>
<p>启动后，执行下面的测试程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	i = syscall(<span class="number">335</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Success!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i = %d"</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果程序输出“Success!”而且源文件内容被成功复制到目标文件，那么任务就完成了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.csdn.net/snoopy19981210/article/details/89957254" target="_blank" rel="noopener">https://blog.csdn.net/snoopy19981210/article/details/89957254</a></li>
<li><a href="https://blog.csdn.net/qq84395064/article/details/86593469" target="_blank" rel="noopener">https://blog.csdn.net/qq84395064/article/details/86593469</a></li>
<li><a href="https://blog.csdn.net/hxmhyp/article/details/22699669" target="_blank" rel="noopener">https://blog.csdn.net/hxmhyp/article/details/22699669</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201412_4 最优灌溉</title>
    <url>/2020/02/07/csp-201412-4-%E6%9C%80%E4%BC%98%E7%81%8C%E6%BA%89/</url>
    <content><![CDATA[<p>摘要：</p>
<p>最小生成树 prim算法</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。<br>　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。<br>　　现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。<br>　　接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>4 4<br>1 2 1<br>2 3 4<br>2 4 2<br>3 4 3</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>6</p>
<h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>　　建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。</p>
<p>###评测用例规模与约定</p>
<p>　　前20%的评测用例满足：n≤5。<br>　　前40%的评测用例满足：n≤20。<br>　　前60%的评测用例满足：n≤100。<br>　　所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不得不说早年的csp考试题目果然很直接。。这道题直接套用prim算法的模板就行甚至都不需要小trick。在这里顺便把prim算法重新说下吧，prim算法主要用来构建最小生成树，算法的主要思想是，所有的点构成点集V，已经被我们访问的点构成点集S，所以点集V就被分为了点集S和点集V-S。我们每次都要从点集V-S中寻找一个距离点集S最近的点加入到点集S中，这个最近的距离所对应的那条边就被加入到最小生成树中。实现的时候，我们需要一个数组d[]，他记录的是<strong>各个节点到集合S的距离</strong>，这道题我是使用邻接矩阵来实现的。一些坑和需要注意的点会在代码注释里面写出来。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];    <span class="comment">//借调到集合S的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] = &#123;<span class="literal">false</span>&#125;;   <span class="comment">//  记录是否被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//默认以第一个节点作为起点</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    fill(d, d+MAXN, INF);   <span class="comment">//注意：fill的第一个和第二个参数应该是指针，所以不要写成了d[0]</span></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min_n = <span class="number">-1</span>, min = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; min)&#123;</span><br><span class="line">                min = d[j];</span><br><span class="line">                min_n = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_n == <span class="number">-1</span>)&#123;    <span class="comment">//注意:这个判断在这道题中似乎是不需要的，但是规范的prim算法应该需要这个判断，当给出的图不是一个连通分量的时候应该返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += min;</span><br><span class="line">        vis[min_n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAXN; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G[min_n][j] &lt; d[j] &amp;&amp; vis[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                d[j] = G[min_n][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    fill(G[<span class="number">0</span>], G[<span class="number">0</span>]+MAXN*MAXN, INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="comment">//注意：题目给出的节点的序号是从1开始的，而我们的数组是从0开始，所以需要减一</span></span><br><span class="line">        <span class="comment">//注意：给G[a-1][b-1]赋值后不要忘记给G[b-1][a-1]赋值，我一开始就忘了=_=</span></span><br><span class="line">        G[a<span class="number">-1</span>][b<span class="number">-1</span>] = c;</span><br><span class="line">        G[b<span class="number">-1</span>][a<span class="number">-1</span>] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; prim(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201409_4 最优配餐</title>
    <url>/2020/02/06/csp-201409-4-%E6%9C%80%E4%BC%98%E9%85%8D%E9%A4%90/</url>
    <content><![CDATA[<p>摘要：</p>
<p>多源最短路径 bfs</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　栋栋最近开了一家餐饮连锁店，提供外卖服务。随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。<br>　　栋栋的连锁店所在的区域可以看成是一个n×n的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。<br>　　方格图中的线表示可以行走的道路，相邻两个格点的距离为1。栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangyazhe/CDN@v1.0/p41.png" alt="题目"></p>
<p>送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费1块钱。每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。<br>　　现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含四个整数n, m, k, d，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。<br>　　接下来m行，每行两个整数xi, yi，表示栋栋的一个分店在方格图中的横坐标和纵坐标。<br>　　接下来k行，每行三个整数xi, yi, ci，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）<br>　　接下来d行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示最优送餐方式下所需要花费的成本。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>10 2 3 3<br>1 1<br>8 8<br>1 5 1<br>2 3 3<br>6 7 2<br>1 2<br>2 2<br>6 8</p>
<p>###样例输出</p>
<p>29</p>
<p>###评测用例规模与约定</p>
<p>　　前30%的评测用例满足：1&lt;=n &lt;=20。<br>　　前60%的评测用例满足：1&lt;=n&lt;=100。<br>　　所有评测用例都满足：1&lt;=n&lt;=1000，1&lt;=m, k, d&lt;=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这种给出格点给出坐标然后求最短路径的问题，第一反应是用bfs，仔细看完题目之后发现这道题是多源最短路径，其实只要bfs稍微变一变就ok。方法就是，初始化的时候将所有的起点都入队列，然后多个起点同时开始bfs。对于每一个起点来说，每一轮循环都会使他们向前探索一步，所以他们入队列的顺序并不会对结果产生影响。</p>
<p>有一个坑需要注意，就是评测用例规模：“1&lt;=n&lt;=1000，1&lt;=m, k, d&lt;=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。”，考虑一种容易考虑的情况，即若左下角(1,1)有唯一一家分店，右上角(1000,1000)有1000,000个顾客，每个顾客的订餐量为1000，无禁止通过的点。那么，从分店(1,1)走到顾客所在的点(1000,1000)需要<strong>2000</strong>步左右；然后1000,000个顾客，每人订餐量1000，总订餐量10^9，总共花费2000 * 10^9 = 2 * 10^12，显然这超出了int的范围，所以要使用long long类型。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point_info</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Legal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;n)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> customer_need[MAX_SIZE+<span class="number">1</span>][MAX_SIZE+<span class="number">1</span>] = &#123;<span class="number">0L</span>L&#125;;<span class="comment">//记录一个点所有顾客的总需求 </span></span><br><span class="line"><span class="keyword">int</span> customers[MAX_SIZE+<span class="number">1</span>][MAX_SIZE+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//记录同一点有几个顾客 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,k,d,x,y;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>,value;</span><br><span class="line">	<span class="built_in">queue</span>&lt;point_info&gt; q;</span><br><span class="line">	<span class="keyword">bool</span> ban[MAX_SIZE+<span class="number">1</span>][MAX_SIZE+<span class="number">1</span>] = &#123;<span class="literal">false</span>&#125;; <span class="comment">//  不能走的位置</span></span><br><span class="line">	point_info front,t;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> move[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;k,&amp;d);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="comment">//初始化时，将所有的起点全部入队列</span></span><br><span class="line">		point_info start;</span><br><span class="line">		start.step = <span class="number">0L</span>L;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;start.x,&amp;start.y);</span><br><span class="line">		ban[start.x][start.y] = <span class="literal">true</span>;   <span class="comment">//餐厅的位置不能走</span></span><br><span class="line">		q.push(start);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="comment">//同一个位置不论有多少客户或者多少需求，都一定是由距离最近的那个餐厅进行配送，所以直接将需求加在一起就行</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %lld"</span>,&amp;x,&amp;y,&amp;value);</span><br><span class="line">		customer_need[x][y] += value;</span><br><span class="line">		customers[x][y]++; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(d--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">		ban[x][y] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		front = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(customer_need[front.x][front.y]!=<span class="number">0L</span>L)&#123;</span><br><span class="line">			k -= customers[front.x][front.y];</span><br><span class="line">			ans += front.step * customer_need[front.x][front.y];</span><br><span class="line">			<span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			x = front.x+move[i][<span class="number">0</span>];</span><br><span class="line">			y = front.y+move[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(Legal(x,y,n)&amp;&amp;!ban[x][y])&#123;</span><br><span class="line">				t.x = x;</span><br><span class="line">				t.y = y;</span><br><span class="line">				t.step = front.step + <span class="number">1</span>;</span><br><span class="line">				ban[x][y] = <span class="literal">true</span>;</span><br><span class="line">				q.push(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201403_4 无线网络</title>
    <url>/2020/02/05/csp-201403-4-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>摘要：</p>
<p>最短路径 bfs</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。<br>　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。<br>　　接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。<br>　　接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。<br>　　输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>5 3 1 3<br>0 0<br>5 5<br>0 3<br>0 5<br>3 5<br>3 3<br>4 4<br>3 0</p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>2</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>路由器构成了一个图，如果两个路由器之间的距离小于r则存在边。问题要求解的是最短路径，所有边的权都为1，考虑使用BFS。搜索时要记录已经增设的路由器数量，确保路由器数量不超过k。</p>
<h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 210</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;    <span class="comment">//序号</span></span><br><span class="line">    <span class="keyword">int</span> new_router_num; <span class="comment">//新增路由器数量</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">//路径长度</span></span><br><span class="line">    node(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):num(a), new_router_num(b), length(c)&#123;&#125;    <span class="comment">//构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K, R;</span><br><span class="line"><span class="keyword">bool</span> graph[MAXN][MAXN];	<span class="comment">//graph[i][j]的值代表着第i个点和第j个点之间是否有边，即第i个点与第j个点之间的距离是否小于r </span></span><br><span class="line"><span class="keyword">int</span> pos[MAXN][<span class="number">2</span>];	<span class="comment">//每行代表一个元素，两列分别是x坐标和y坐标 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inRange</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pos[a][<span class="number">0</span>]-pos[b][<span class="number">0</span>],<span class="number">2</span>)+<span class="built_in">pow</span>(pos[a][<span class="number">1</span>]-pos[b][<span class="number">1</span>],<span class="number">2</span>))&lt;=R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(M+N)</span></span>;	<span class="comment">//记录某结点是否被访问过 </span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node &gt; q;</span><br><span class="line">    <span class="function">node <span class="title">start</span><span class="params">(s, <span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    q.push(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node f = q.front();</span><br><span class="line">        <span class="keyword">if</span>(f.num == t) <span class="keyword">return</span> f.length<span class="number">-2</span>;	<span class="comment">//到达了终点 </span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;	<span class="comment">//不考虑新增路由器的情况下选择路径的下一个结点 </span></span><br><span class="line">            <span class="keyword">if</span>(graph[f.num][i] &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                <span class="function">node <span class="title">temp</span><span class="params">(i, f.new_router_num, f.length + <span class="number">1</span>)</span></span>;   <span class="comment">//因为不考虑新增路由器，所以f.new_router_num不变 </span></span><br><span class="line">                q.push(temp);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N; i&lt;N+M; i++) &#123;	<span class="comment">//仅考虑新增路由器的情况下选择路径的下一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(graph[f.num][i] &amp;&amp; !visited[i] &amp;&amp; f.new_router_num&lt;K) &#123;</span><br><span class="line">                <span class="function">node <span class="title">temp</span><span class="params">(i, f.new_router_num + <span class="number">1</span>, f.length + <span class="number">1</span>)</span></span>;</span><br><span class="line">                q.push(temp);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;N, &amp;M, &amp;K, &amp;R);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N+M; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;pos[i][<span class="number">0</span>], &amp;pos[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N+M; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;N+M; j++) &#123;</span><br><span class="line">            graph[i][j] = graph[j][i] = inRange(i, j, R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, bfs(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>csp 201812_2小明放学（C++）AC代码</title>
    <url>/2020/01/31/csp-201812-2%E5%B0%8F%E6%98%8E%E6%94%BE%E5%AD%A6%EF%BC%88C-%EF%BC%89AC%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>摘要：</p>
<p>汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。</p>
<a id="more"></a>

<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了出发时刻路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 10^6^。<br>　　输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。<br>　　接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 10^6^；k=1、2、3 时，分别表示出发时刻，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。<br>输出格式<br>　　输出一个数字，表示此次小明放学回家所用的时间。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>30 3 30<br>8<br>0 10<br>1 5<br>0 11<br>2 2<br>0 6<br>0 3<br>3 10<br>0 3</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>46</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。<br>评测用例规模与约定<br>　　有些测试点具有特殊的性质：<br>　　* 前 2 个测试点中不存在任何信号灯。<br>　　测试点的输入数据规模：<br>　　* 前 6 个测试点保证 n ≤ 10^3^。<br>　　* 所有测试点保证 n ≤ 10^5^。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>1.由于每个信号灯的类型会随着时间的推移而改变，所以定义信号灯结构体，结构体中包含目前信号灯的类型以及距离下一次信号类型发生改变剩余的时间。<br>2.问题的核心在于，求出经过t时间后，小明达到某个红绿灯时，红绿灯的类型以及剩余时间。只需要记录好小明到达某个红绿灯时已经使用的时间，即可推算此时红绿灯是什么类型。由于红绿灯是每经过(r+g+y)s就会循环一次，故使用t%(r+g+y)来推断红绿灯类型，如果不这样做会超时<br>3.需要注意，题目中已经说明，经过一段路所需时间和红绿灯等待时间均最多为10^6^s，道路的段数n最大为10^5^，那么小明回家所需时间最大就有可能是10^11^，此时已经超过int型数据所能表示的范围，故代码中的整数均直接定义成long long类型。<br>4.要注意黄灯结束后紧接着是红灯，依然需要等待</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//容易出错的点</span></span><br><span class="line"><span class="comment">//1.由于数据量大，t需要定义成long longl类型</span></span><br><span class="line"><span class="comment">//2.黄灯结束后，还需要紧接着等红灯</span></span><br><span class="line"><span class="comment">//3.小心超时</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义结构体，其中包含类型和时间两个信息。</span></span><br><span class="line"><span class="comment">// 另外构造一个函数，用于计算某一个红绿灯经过t时间后是什么类型的灯以及剩余多少时间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sig</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> time_left;</span><br><span class="line">&#125;sig;</span><br><span class="line"><span class="function">sig <span class="title">next_state</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> y, <span class="keyword">int</span> g, sig p, <span class="keyword">long</span> <span class="keyword">long</span> t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, y, g, n, i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;</span><br><span class="line">    sig p, ret_sig;</span><br><span class="line">    <span class="built_in">vector</span>&lt;sig&gt; state;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; y &gt;&gt; g;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p.type &gt;&gt; p.time_left;</span><br><span class="line">        <span class="built_in">cin</span>.get();</span><br><span class="line">        state.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        p = state[i];</span><br><span class="line">        <span class="keyword">if</span>(p.type == <span class="number">0</span>)&#123;</span><br><span class="line">            t+=p.time_left;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            ret_sig = next_state(r, y, g, state[i], t);</span><br><span class="line">            <span class="keyword">if</span>(ret_sig.type == <span class="number">1</span>)&#123;</span><br><span class="line">                t+=ret_sig.time_left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret_sig.type == <span class="number">2</span>)&#123;</span><br><span class="line">            	t+=ret_sig.time_left;</span><br><span class="line">            	t+=r;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sig <span class="title">next_state</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> y, <span class="keyword">int</span> g, sig p, <span class="keyword">long</span> <span class="keyword">long</span> t)</span></span>&#123;</span><br><span class="line">    sig ret_sig;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">4</span>];</span><br><span class="line">    time[<span class="number">1</span>]=r;</span><br><span class="line">    time[<span class="number">2</span>]=y;</span><br><span class="line">    time[<span class="number">3</span>]=g;</span><br><span class="line">    ret_sig.type = p.type;</span><br><span class="line">    ret_sig.time_left = p.time_left;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;r+g+y)&#123;</span><br><span class="line">    	t=t%(r+g+y);<span class="comment">//important point to optimize the time cost</span></span><br><span class="line">	&#125;</span><br><span class="line">    ret_sig.time_left-=t;</span><br><span class="line">    <span class="keyword">if</span>(ret_sig.time_left&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ret_sig.type--;</span><br><span class="line">            <span class="keyword">if</span>(ret_sig.type == <span class="number">0</span>) ret_sig.type=<span class="number">3</span>;</span><br><span class="line">            ret_sig.time_left+=time[ret_sig.type];</span><br><span class="line">        &#125;<span class="keyword">while</span> (ret_sig.time_left&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_sig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2020/01/30/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>摘要：</p>
<p>依据廖雪峰的教程和网上其他一些博客的内容整理，涵盖了平时比较常用的指令和操作，适合于零基础的同学。可能会有表述不合适的地方，欢迎指正。</p>
<a id="more"></a>

<ul>
<li>创建版本仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;新建一个文件夹，使用git init命令</span><br><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure></li>
<li>把一个文件放到Git仓库需要两步   <ol>
<li>$ git add readme.txt</li>
<li>$ git commit -m “wrote a readme file”<br>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</li>
</ol>
</li>
<li>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure></li>
<li>git status命令可以让我们时刻掌握仓库当前的状态，下面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li>
<li>使用git diff可以查看对文件进行的修改<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a&#x2F;readme.txt</span><br><span class="line">+++ b&#x2F;readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure></li>
<li>git log查看历史记录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)&#x2F;&#x2F;版本号</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></li>
<li>git reset命令可以回退到之前的版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure></li>
<li>如果从A回退到B之后后悔了，又想返回A，这时必须查看历史记录找到A的版本号，然后使用git reset. 如果这中间关掉了终端，导致历史的命令行记录看不了，可以使用 git reflog 命令查看之前的命令，然后就可以找到之前的版本号<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a&#x2F;&#x2F;版本号不需要写全，只写前几位就ok</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></li>
<li>比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone.一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone.一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:michaelliao&#x2F;bootstrap.git</span><br></pre></td></tr></table></figure></li>
<li>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送.<br>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</li>
<li>合并分支<br><a href="https://cloud.tencent.com/developer/news/242399" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/242399</a></li>
<li>github使用流程   <ol>
<li>在本地新建一个文件夹，并且执行init add commit操作</li>
<li>使用  git remote add origin <a href="mailto:git@github.com">git@github.com</a>:zhangyazhe/仓库名.git 命令将本地仓库与远程仓库建立连接</li>
<li>在push之前，先pull一下，保证本地仓库和远程仓库是一样的，否则会报错，即执行 git pull –rebase origin master</li>
<li>下一步，就可以把本地库的所有内容推送到远程库上：使用git push -u origin master , 这里实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。从这之后，就可以通过git push origin master来进行push</li>
</ol>
</li>
<li>进行git push时可能会出现下面的问题：   <ol>
<li>git 出现 fatal: refusing to merge unrelated histories 错误。其实这个问题是因为两个根本不相干的git库，一个是本地库，一个是远端库，然后本地要去推送到远端，远端觉得这个本地库跟自己不相干，所以告知无法合并。这个错误可以忽略</li>
<li>有时候会出现无法push的情况，可能是因为远程仓库用有README但是本地没有，这样就出现了冲突。在git pull中添加了–rebase之后，就可以将远程仓库有但是本地仓库没有的文件下载下来，从而解决了冲突。例如，执行完带有–rebase之后，本地仓库就会出现README。命令为 git pull –rebase origin master</li>
<li>建议是在github上面新建repo的时候不要加上README，而是在本地仓库中加上README。这样一来远程是空的，就不会有冲突。</li>
</ol>
</li>
<li>使用删除本地仓库中的文件之后使用git add *和git commit和git push之后，发现远程仓库中的对应文件并没有被删除，这是因为使用git add *的话，并没有包含删除信息。这个时候可以使用git add –all或者git add -A，这样一来远程仓库对应为文件也会被删除</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>模电复习笔记</title>
    <url>/2020/01/30/%E6%A8%A1%E7%94%B5%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>摘要：</p>
<p>这篇博文是大二的时候学习模拟电子技术时候期末复习的笔记，适用于华中科技大学的学弟学妹们，结合华中科技大学mooc模电课程效果更佳</p>
<a id="more"></a>

<h1 id="模拟电子技术基础期末复习"><a href="#模拟电子技术基础期末复习" class="headerlink" title="模拟电子技术基础期末复习"></a>模拟电子技术基础期末复习</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><ul>
<li>描述放大电路输出量与输入量之间关系的曲线称为传输特性曲线。<h2 id="第二章-运算放大器"><a href="#第二章-运算放大器" class="headerlink" title="第二章 运算放大器"></a>第二章 运算放大器</h2></li>
<li>开环电压增益即运放由输出端到输入端无外接反馈元件事的电压增益，运放电路的功能是用来放大两个输入信号的差值。</li>
<li>运放的增益越高，线性区的直线越陡，输入电压的线性范围越小。</li>
<li>如果直接将电压源接在运放的两端，基本都会超过线性区而导致失真，这才引入了负反馈，主要目的是通过负反馈来减小加载输入端的信号从而保证工作在线性区。这时的线性工作区会明显变大，这时的增益成为闭环增益Av。</li>
<li>电压跟随器可以增大输出电阻，帮助负载抢夺电压，提高了电路的带负载能力。</li>
<li>运放只有工作在线性区，虚短才成立。因为只有在线性区才有开环电压增益为无穷大，才能根据输出电压有限推出输出电压近似为零。</li>
<li>深度负反馈是虚短的条件</li>
<li>实际运放由负反馈链接的线路也可以得到虚短和虚断的概念，与理想运放特性相同</li>
<li>运放构成的放大电路的指标与运算放大器本身的指标含义是不同的。</li>
<li>反馈电阻必须加在反向端与输出端之间，否则不是负反馈。</li>
<li>对于虚地，只是表明这个节点的电压可以近似视为零，但它并不是真的接地。<h2 id="第三章-二极管及其基本电路"><a href="#第三章-二极管及其基本电路" class="headerlink" title="第三章 二极管及其基本电路"></a>第三章 二极管及其基本电路</h2></li>
<li>本征激发，温度引起。</li>
<li>电场导致的是漂移，浓度导致的是扩散。</li>
<li>P区点位高于N区点位时，称之为正向偏置。</li>
<li><code>反向电流IR，反向饱和电流Is,VT温度电压当量，常温下为26mv，VBR为反向击穿电压，Vth开启电压</code></li>
<li>二极管大信号模型：理想模型、恒压降模型、折现模型。</li>
<li><code>通常，小信号模型中，二极管两端电流为ID，二极管两端电压VD，二极管动态电阻rd。其中，rd=VT/ID。</code></li>
<li>在二极管小信号模型中，微变电阻rd=VT/ID。其中VT=26mv，ID由静态工作点决定</li>
<li>在已知特性曲线的前提下，可以使用图解法建立小信号模型。<h2 id="第四章-场效应三极管及其放大电路"><a href="#第四章-场效应三极管及其放大电路" class="headerlink" title="第四章 场效应三极管及其放大电路"></a>第四章 场效应三极管及其放大电路</h2></li>
<li>由于vgs可以控制漏极电流，所以常常将GS作为输入端口，将DS作为输出端口。</li>
<li>场效应管的放大作用就是通过vgs对漏极电流的控制实现的，所以用场效应管放大信号时，需要让场效应管工作在饱和区。对于vgs和漏极电流之间的关系的研究在使用场效应管对信号进行放大的过程中十分重要。</li>
<li>考虑沟道长度调制效应时，饱和区的输出特性曲线是倾斜的，其斜率就是输出端口的电阻rds的倒数。rds也称为动态电阻或交流电阻。根据表达式，vgs确定后，rds也就确定了。</li>
<li>转移特性直接反映了输入电压对输出电流的控制作用，由于用于放大信号的场效应管必须工作在饱和区，所以我们只对饱和区进行讨论。根据饱和区电流计算公式，即可画出转移特性曲线。在曲线上某一点Q做切线，切线的斜率就是电导，由于这个是联系输入端口电压和输出端口电流，所以又称为跨导或互导。用gm表示。可以发现，Q点位置不同，gm也不同。跨导将输入端口电压vgs与漏极电流id联系了起来。</li>
<li>（图4.2.1）通常来讲，输入的vGS是交流量和直流量的叠加，所以漏极电流和漏源电压也是直流量和交流量的叠加。</li>
<li>iD=ID+id。三者的大小写字母匹配为：总量=直流量+交流量。</li>
<li>（图4.2.1）由漏极回路看出，漏极电流方向不会反转，当电流id减小到0时，输出电压达到最大值，等于VDD。当电流id增大，可以使得输出电压接近于零，所以输出电压vds一定是在0到VDD之间。如果VGG或者Rd选择不恰当，使得vDSQ过高或者过低，都会导致输出波形明显失真。（图4.3.5、图4.3.6）</li>
<li>必须让MOSFET工作在饱和区，别且有合适的静态偏置。</li>
<li>信号经常又被叫做交流量或者变化量。</li>
<li>输出信号的幅值受输出回路电源电压的限制。</li>
<li>直流电源既是MOSFET正常工作的前提条件，优势信号放大的能量供给者。</li>
<li>求出静态指标后，需要校验是否满足饱和区的工作条件。</li>
<li>解题时一般先假设工作在饱和区，利用饱和区特性方程求解，最后验证是否工作在饱和区。<h4 id="图解法"><a href="#图解法" class="headerlink" title="图解法"></a>图解法</h4></li>
<li>求交流负载线方程时，首先根据交流通路图写出交流量之间的关系，接着利用‘交流量=总量-直流量’这个关系待入交流量的方程，即可得到vDS与iD之间的关系，就可以画在输出特性图里面了。（书P111）<h4 id="小信号模型分析法"><a href="#小信号模型分析法" class="headerlink" title="小信号模型分析法"></a>小信号模型分析法</h4></li>
<li>由于栅极是绝缘的，所以栅源之间的端口是开路状态。如果考虑沟道长度调制效应，那么在输出端口就有一个输出电阻rds。</li>
<li>跨导是转移特性曲线上Q点切线的斜率。输出电阻是传输特性曲线上Q点斜率的倒数。</li>
<li>受控源的电流方向和控制电压的极性是关联的，改变其中一个，另外一个也要改变。<h4 id="共源极、共栅极、共漏极放大电路"><a href="#共源极、共栅极、共漏极放大电路" class="headerlink" title="共源极、共栅极、共漏极放大电路"></a>共源极、共栅极、共漏极放大电路</h4></li>
<li>计算放大电路输入电阻时，不考虑信号源内阻。</li>
<li>放大电路的组态与静态偏置无关，所以不同的组态具有不同的动态指标，而相同的组态，即使静态偏置方式不同，他们的动态指标也是基本相同的。<h4 id="多级放大电路"><a href="#多级放大电路" class="headerlink" title="多级放大电路"></a>多级放大电路</h4></li>
<li>前级的开路电压是后级的信号源电压</li>
<li>前级的输出电阻是后级的信号源内阻</li>
<li>对于共源-共漏放大电路，虽然共漏的增益约等于一，但是由于其输入电阻很大，可以使得前一级增益变大，同时由于共漏的输出电阻很小，两级总增益还是会比单共源提高不少<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4></li>
<li>判断电路对信号是否有放大作用，首先判断静态偏置是否合理，是否满足线性区的要求。其次判断交流通路。最后总的观察通路是否畅通或是否短路。<h2 id="第五章-双极结型三极管及其放大电路"><a href="#第五章-双极结型三极管及其放大电路" class="headerlink" title="第五章 双极结型三极管及其放大电路"></a>第五章 双极结型三极管及其放大电路</h2><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4></li>
<li>PN结外加正向电压时，耗尽区变窄，外加反向电压时，耗尽区变宽</li>
<li>发射结电压与集电极电流的控制关系：发射结电压与发射极电流的关系就是之前的PN结正偏时的电压电流关系（近似指数），发射结电压增大后，发射极电流也增大，会有更多的电子进入到基区，进而导致更多的电子进入到集电区，而集电极电流主要就是由这部分电子形成，所以发射结电压能够控制集电极电流</li>
<li>ICBO是在PN结外加反向电压形成的，即为反向饱和电流，电流较小</li>
<li>一旦三极管制成，α和β的值就确定了</li>
<li>BJT工作的外部条件：发射结正偏，集电结反偏</li>
<li>用BJT放大信号时，一般是通过改变发射结正偏电压，来改变基极电流或发射极电流，从而控制集电极电流，所以通常发射极和基极作为输入端，集电极总是在输出回路中</li>
<li>在BJT中，电子和空穴都参与了导电，所以称为双极结型</li>
<li>BJT的输出特性曲线：当vCE固定时，若iB增加，意味着一定是因为发射结电压增加，必然同时引起发射极电流增加，从而会导致集电极电流增加</li>
<li>截止区的形成是因为发射结的正向偏置电压小于开启电压</li>
<li>由于基区宽度调制效应，vCE增加会导致基区有效宽度减小，载流子在基区复合的机会变小，使得电流放大系数β增加，所以输出特性曲线上翘</li>
<li>描述静态工作点时，通常使用IBQ ICQ VCEQ<h4 id="BJT的静态偏置和放大电路构成"><a href="#BJT的静态偏置和放大电路构成" class="headerlink" title="BJT的静态偏置和放大电路构成"></a>BJT的静态偏置和放大电路构成</h4></li>
<li>一般硅管VBEQ=0.7V，锗管VBEQ=0.2V<h4 id="BJT的小信号等效模型"><a href="#BJT的小信号等效模型" class="headerlink" title="BJT的小信号等效模型"></a>BJT的小信号等效模型</h4></li>
<li>（图5.3.11）受控源βib的电流方向和控制电流ib的方向是关联的</li>
<li>因为bjt小信号模型反映的是电压电流变化量之间的关系，所以与NPN或者PNP型无关</li>
<li>（图5.4.2）计算Re输入等效电阻，使用p186的方法</li>
<li>（图5.4.2）引入Re后，增益会下降，但是可以减小非线性失真，增大放大电路的频带宽度（实际是负反馈）<h4 id="MOS与BJT的比较"><a href="#MOS与BJT的比较" class="headerlink" title="MOS与BJT的比较"></a>MOS与BJT的比较</h4></li>
<li>两种三极管的六种组态可以分为三类：反向电压放大器（增益高、输入电阻大）、电压跟随器（输入电阻高、输出电阻低）、电流跟随器（输入电阻小）<h4 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h4></li>
<li>交流通路中，将二极管用小信号模型等效，再去掉直流电源，最终只剩下rd。计算方法见p66<h2 id="第六章-放大电路的频率响应"><a href="#第六章-放大电路的频率响应" class="headerlink" title="第六章 放大电路的频率响应"></a>第六章 放大电路的频率响应</h2><h4 id="单时间常数RC电路的频率响应"><a href="#单时间常数RC电路的频率响应" class="headerlink" title="单时间常数RC电路的频率响应"></a>单时间常数RC电路的频率响应</h4></li>
<li>AVM中的M指的是中频区<h4 id="三极管放大电路的高频响应"><a href="#三极管放大电路的高频响应" class="headerlink" title="三极管放大电路的高频响应"></a>三极管放大电路的高频响应</h4></li>
<li>当MOS管和信号源确定后，增益带宽积为定值<h2 id="第七章-模拟集成电路"><a href="#第七章-模拟集成电路" class="headerlink" title="第七章 模拟集成电路"></a>第七章 模拟集成电路</h2><h4 id="集成电路中的直流偏置——电流源电路"><a href="#集成电路中的直流偏置——电流源电路" class="headerlink" title="集成电路中的直流偏置——电流源电路"></a>集成电路中的直流偏置——电流源电路</h4></li>
<li>在集成电路中，一个三极管比一个电阻所占用的面积更小，所以一般不采用电阻来作为偏置，而是采用三极管构成直流电流源，为放大管提供静态偏置</li>
<li>三极管做电流源时，vGS始终是恒定的，对应一条不变的输出特性曲线，当负载改变时，负载线的斜率发生变化，但是交点始终在输出特性曲线上，漏极电流是不会改变的，便达到恒流效果</li>
<li>根据以上可以看出，MOS做电流源时，必须满足两个条件：一是vGS保持不变，二是MOS必须工作在饱和区（这样才能保证静态工作点在输出特性曲线的水平部分移动）</li>
<li>饱和区输出特性曲线的斜率的倒数，实际上就是电流源的内阻。忽略沟道长度调制效应时，内阻为无穷大<h4 id="差分式放大电路"><a href="#差分式放大电路" class="headerlink" title="差分式放大电路"></a>差分式放大电路</h4></li>
<li>只有直接耦合放大电路才会有零点漂移问题<h4 id="MOSFET源极耦合差分式放大电路"><a href="#MOSFET源极耦合差分式放大电路" class="headerlink" title="MOSFET源极耦合差分式放大电路"></a>MOSFET源极耦合差分式放大电路</h4></li>
<li>双端输出是单端输出幅值的两倍</li>
<li>单端输入时的差模情况等效于双端输入</li>
<li>无论何种输出方式，共模增益都远小于差模增益。这是因为ro的影响</li>
<li>差分式放大电路的输入电阻分为两类，差模输入电阻和共模输入电阻</li>
<li>差分式放大电路对共模信号有很强的放大能力而对差摸信号有很强的抑制能力，产生这种作用的根本原因是源极公共支路，方法差摸信号时，源极公共支路相当于短路，而放大共模信号时，公共支路不再短路，支路上的电阻会明显影响增益的大小<h4 id="BJT差分式放大电路"><a href="#BJT差分式放大电路" class="headerlink" title="BJT差分式放大电路"></a>BJT差分式放大电路</h4></li>
<li>由于BJT的基极不再像栅极那样是绝缘的，所以输入电阻不再是无穷大<h4 id="集成运算放大器简介"><a href="#集成运算放大器简介" class="headerlink" title="集成运算放大器简介"></a>集成运算放大器简介</h4></li>
<li>一般都可以分为输入级、中间级、输出级。输入级通常是高共模抑制比的差分式放大电路，输出级主要特点是具有较强的驱动负载的能力</li>
<li>高增益是集成运放的最基本特征<h4 id="集成运放的主要参数"><a href="#集成运放的主要参数" class="headerlink" title="集成运放的主要参数"></a>集成运放的主要参数</h4></li>
<li>三极管一定需要有直流通路，这样三极管才能有合适的静态工作点。如此一来，运放的两输入端就会有一定的静态电流。</li>
<li>失调电流、偏置电流等并不影响虚短和虚断的正常使用 </li>
<li>运放的输入端必须要有直流通路，运放里面的差分放大电流才能有合适的偏置<h2 id="第八章-反馈放大电路"><a href="#第八章-反馈放大电路" class="headerlink" title="第八章 反馈放大电路"></a>第八章 反馈放大电路</h2><h4 id="反馈的基本概念与分类"><a href="#反馈的基本概念与分类" class="headerlink" title="反馈的基本概念与分类"></a>反馈的基本概念与分类</h4></li>
<li>没有明显反馈线的负反馈：例如图4.5.1（a）。源极电阻就是反馈通路，漏极电流就是输出电流，他会在源极电阻上产生压降，这个压降会影响g与s之间的电压，进而影响到漏极电流，所以构成了反馈通路</li>
<li>根据反馈到输入端信号的性质，来区分交流反馈还是直流反馈</li>
<li>理想情况下，电源线和地线不是反馈通路，因为他们上面的电压始终是恒定的。</li>
<li>对于电流信号源，使用并联反馈效果更明显。对于电压信号源，使用串联反馈效果更明显。原因都在于，反馈电压或电流的变化可以直接影响经输入电压或电流的变化</li>
<li>判断依据：并联反馈的特点是，输入信号和反馈信号接在同一个输入端上。而串联反馈输入信号和反馈信号一般接在不同输入端上</li>
<li>串联反馈的输入端口以电压形式求和，并联反馈的输入端口以电流形式求和</li>
<li>是电流反馈还是电压反馈由反馈网络的输入端口在放大电路的输出端口取样的对象来决定</li>
<li>直接判断是电压反馈还是电流反馈比较困难，所以使用输出短路法来进行判断</li>
<li>负反馈会使电路的增益下降</li>
<li>BJT的集电极与基极信号的相位是相反的，因为共射极放大电路的增益为负</li>
<li>（图8.1.5a）反馈回路是由Re1组成的，由与射极与基极一同组成了输入端口的同时，还与集电极一同组成了输出端口，所以位于射极上的Re1依然处于输出之中，从而可以将输出的一部分回送到输出</li>
<li>串联与并联看的是输入端口，（取样）电压与（取样）电流看的是输出端口</li>
<li>单纯的直流反馈主要用于稳定静态工作点，交流反馈或直流反馈用于对信号放大产生影响<h4 id="负反馈对放大电路性能的影响"><a href="#负反馈对放大电路性能的影响" class="headerlink" title="负反馈对放大电路性能的影响"></a>负反馈对放大电路性能的影响</h4></li>
<li>引入负反馈可以稳定增益。反馈的组态不同，稳定的增益也不同。例如电压串联负反馈只能稳定闭环电压增益，电流串联负反馈只能稳定闭环互导增益</li>
<li>负反馈只能减小反馈环内产生的失真</li>
<li>只有在放大电路的带宽可以近似为上限频率并且只有一个上限转折频率的情况下，增益带宽积为常数的结论才成立<h4 id="负反馈放大电路的稳定性"><a href="#负反馈放大电路的稳定性" class="headerlink" title="负反馈放大电路的稳定性"></a>负反馈放大电路的稳定性</h4></li>
<li>在没有任何输入信号的情况下，放大电路的输出端仍会连续不断地产生某种频率和幅度的输出信号。这种现象就是自激振荡<h2 id="第十章-信号处理与信号产生电路"><a href="#第十章-信号处理与信号产生电路" class="headerlink" title="第十章 信号处理与信号产生电路"></a>第十章 信号处理与信号产生电路</h2><h4 id="高阶有源滤波器"><a href="#高阶有源滤波器" class="headerlink" title="高阶有源滤波器"></a>高阶有源滤波器</h4></li>
<li>滤波特性取决于传递函数，不同的电路可以有相同的传递函数<h4 id="正弦波震荡电路"><a href="#正弦波震荡电路" class="headerlink" title="正弦波震荡电路"></a>正弦波震荡电路</h4></li>
<li>如果希望w0的正弦波震荡输出，就只能允许w0的正弦波既满足振幅平衡条件又满足相位条件。所以需要选频网络</li>
<li>自激振荡的信号源头是电路中的噪声等，他们的频率分布很广，其中必然包含频率为wo的信号，选频网络将他选出，在环路中形成正反馈。但是他的幅值很小，不能满足要求，所以必须对他进行放大，这个过程称为起振，在这个过程中，需要AF绝对值大于一，从而对信号进行放大，放大到一定程度后，进行稳幅，使得AF稳定为1。所以振荡电路应该包括选频——起振——稳幅环节。所以振荡电路就会由以下部分组成：放大、正反馈、选频和稳幅<h4 id="电压比较器"><a href="#电压比较器" class="headerlink" title="电压比较器"></a>电压比较器</h4></li>
<li>如果是同向输入，传输曲线向一三方向延伸，如果是反向输入，传输曲线向二四方向延伸</li>
<li>在反向迟滞比较器中，只要输入大于上门限，输出就为低电平；只要输入小于下门限，输出就为高电平。同向迟滞比较器与之刚好相反</li>
<li>输入介于上下门限之间时，输出不变</li>
</ul>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP零碎知识点整理</title>
    <url>/2020/01/30/CSP%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>摘要：</p>
<p>祝看过这篇博文的同学CSP都能考到300以上(￣▽￣)~*</p>
<p>笔记里面主要记录的是我在准备CSP过程中遇到过得问题或者学习到的新知识，涵盖C语言、C++、算法等方面内容，由于我是遇到啥写啥，所以内容有点散，不过还是希望所有读过的同学都能有所收获~</p>
<a id="more"></a>

<ul>
<li>判断整数是奇数还是偶数时，可以让这个数与1进行按位与，即num&amp;1，如果结果为1，则num为奇数，否则为偶数</li>
<li>进行整数向浮点数的转换时，可以乘以1.0</li>
<li>C++ vector容器浅析 <a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a><br>删除指定元素可以这样做： 删除第二个元素 (vec[1])<br>vec.erase(vec.begin() + 1);</li>
<li>C++ list总结 <a href="https://www.cnblogs.com/loleina/p/5179677.html" target="_blank" rel="noopener">https://www.cnblogs.com/loleina/p/5179677.html</a></li>
<li>C++ set成员函数用法总结 <a href="https://blog.csdn.net/qq_34243930/article/details/81481929" target="_blank" rel="noopener">https://blog.csdn.net/qq_34243930/article/details/81481929</a><br>set中的元素可以是pair，排序时，先按照first排序，相同的话再按照second排序。元素为pair时，set的find函数就不太好用了，这时可以使用upper_bound函数或者lower_bound()函数，函数中的比较规则也是先看first再看second。lower_bound()函数返回的是第一个不小于给定元素key的位置，upper_bound() 函数返回的是第一个大于给定元素key的位置。<br>例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set&lt;pair&lt;int, int&gt; &gt; st;</span><br><span class="line">set&lt;pair&lt;int, int&gt; &gt;::iterator st_it;</span><br><span class="line">st.insert(make_pair(2, 6));</span><br><span class="line">st.insert(make_pair(1, 5)); </span><br><span class="line">st.insert(make_pair(3, 7));       </span><br><span class="line">st.insert(make_pair(4, 8));</span><br><span class="line">cout &lt;&lt; &quot;遍历输出&quot; &lt;&lt; endl;</span><br><span class="line">for(st_it &#x3D; st.begin(); st_it !&#x3D; st.end(); st_it++)&#123;</span><br><span class="line">    cout &lt;&lt; st_it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">st_it &#x3D; st.lower_bound(make_pair(3, 7));</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; &quot;查找输出&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; st_it-&gt;second;</span><br></pre></td></tr></table></figure></li>
<li>C++ map的基本操作和使用 <a href="https://blog.csdn.net/qq_40914533/article/details/81981467" target="_blank" rel="noopener">https://blog.csdn.net/qq_40914533/article/details/81981467</a></li>
<li>qsort()函数 <a href="https://www.runoob.com/cprogramming/c-function-qsort.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-function-qsort.html</a></li>
<li>C++ sort()函数 <a href="https://www.cnblogs.com/TX980502/p/8528840.html" target="_blank" rel="noopener">https://www.cnblogs.com/TX980502/p/8528840.html</a><br>sort和qsort之间更推荐sort<br>概述：需要头文件<algorithm><br>语法描述：sort（begin，end，cmp），cmp参数可以没有，如果没有默认非降序排序，end为最后一个元素再后面一个位置的指针<br>对于cmp函数的编写，如果return a&gt;b; 则理解为使用&gt;号对元素进行排序。<br>其实对于这么简单的任务（类型支持“&lt;”、“&gt;”等比较运算符），完全没必要自己写一个类出来。标准库里已经有现成的了，就在functional里，include进来就行了。functional提供了一堆基于模板的比较函数对象。它们是（看名字就知道意思了）：equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>。对于这个问题来说，greater和less就足够了，直接拿过来用：<br>升序：sort(begin,end,less<data-type>());<br>降序：sort(begin,end,greater<data-type>()).<br>详见文中：字符串内的字符排序、字符串之间排序、结构体的二级排序</li>
<li>C++ 运算符的重载 <a href="https://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-overloading.html</a></li>
<li>C++ 关系运算符的重载 <a href="https://www.runoob.com/cplusplus/relational-operators-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/relational-operators-overloading.html</a></li>
<li>C++ 优先队列priority_queue用法详解 <a href="https://blog.csdn.net/weixin_36888577/article/details/79937886" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36888577/article/details/79937886</a><br>优先队列中的内容默认是从大到小</li>
<li>一个函数实现16进制的数字与字符之间的转换：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;关键在于形参是char类型</span><br><span class="line">char getc(char c)&#123;   </span><br><span class="line">    if(c&lt;10)   </span><br><span class="line">        return c+&#39;0&#39;;   </span><br><span class="line">    else if(c&lt;&#x3D;16)   </span><br><span class="line">        return c+&#39;A&#39;-10;   </span><br><span class="line">    else if(c&lt;&#x3D;&#39;9&#39;)   </span><br><span class="line">        return c-&#39;0&#39;;   </span><br><span class="line">    else if(c&lt;&#x3D;&#39;F&#39;)   </span><br><span class="line">        return c-&#39;A&#39;+10;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对两个字符进行异或可以使用这个函数：ret=getc(getc(a[i])^getc(b[i]));先将字符转换为整数，进行异或之后再转换回字符</li>
<li>可以用宏来定义for循环，简化代码：#define UP(x) for(uint32_t i=0;i&lt;x;i++)   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UP(8)&#123;</span><br><span class="line">        a[i]&#x3D;getc(getc(a[i])^getc(b[i]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>C++ 引用：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br>引用很容易与指针混淆，它们之间有三个主要的不同：   <ul>
<li>不存在空引用。引用必须连接到一块合法的内存。   </li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。   </li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化</li>
</ul>
</li>
<li>C++  把引用作为返回值 <a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/returning-values-by-reference.html</a></li>
<li>C++ 把引用作为参数 <a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/passing-parameters-by-references.html</a></li>
<li>namespace以及using的用法 <a href="https://www.runoob.com/cplusplus/cpp-namespaces.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-namespaces.html</a></li>
<li>C++ cout：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::showpoint);  &#x2F;&#x2F; 设左对齐，以一般实数方式显示</span><br><span class="line">    cout.precision(5);       &#x2F;&#x2F; 设置除小数点外有五位有效数字 </span><br><span class="line">    cout&lt;&lt;123.456789&lt;&lt;endl;</span><br><span class="line">    cout.width(10);          &#x2F;&#x2F; 设置显示域宽10 </span><br><span class="line">    cout.fill(&#39;*&#39;);          &#x2F;&#x2F; 在显示区域空白处用*填充</span><br><span class="line">    cout&lt;&lt;resetiosflags(ios::left);  &#x2F;&#x2F; 清除状态左对齐</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::right);   &#x2F;&#x2F; 设置右对齐</span><br><span class="line">    cout&lt;&lt;123.456789&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::fixed);    &#x2F;&#x2F; 设左对齐，以固定小数位显示</span><br><span class="line">    cout.precision(3);    &#x2F;&#x2F; 设置实数显示三位小数</span><br><span class="line">    cout&lt;&lt;999.123456&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;resetiosflags(ios::left|ios::fixed);  &#x2F;&#x2F;清除状态左对齐和定点格式</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::left|ios::scientific);    &#x2F;&#x2F;设置左对齐，以科学技术法显示 </span><br><span class="line">    cout.precision(3);   &#x2F;&#x2F;设置保留三位小数</span><br><span class="line">    cout&lt;&lt;123.45678&lt;&lt;endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果为：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123.46</span><br><span class="line">****123.46</span><br><span class="line">999.123</span><br><span class="line">1.235e+02</span><br></pre></td></tr></table></figure>
setiosflags中的常见标志：<br>boolalpha    可以使用单词”true”和”false”进行输入/输出的布尔值.<br>oct    用八进制格式显示数值.<br>dec    用十进制格式显示数值.<br>hex    用十六进制格式显示数值.<br>left    输出调整为左对齐.<br>right    输出调整为右对齐.<br>scientific    用科学记数法显示浮点数.<br>fixed    用正常的记数方法显示浮点数(与科学计数法相对应).<br>showbase    输出时显示所有数值的基数.<br>showpoint    显示小数点和额外的零，即使不需要.<br>showpos    在非负数值前面显示”＋（正号）”.<br>skipws    当从一个流进行读取时，跳过空白字符(spaces, tabs, newlines).<br>unitbuf    在每次插入以后，清空缓冲区.<br>internal    将填充字符回到符号和数值之间.<br>uppercase    以大写的形式显示科学记数法中的”e”和十六进制格式的”x”.   </li>
<li><strong>C++</strong> 输入：<ul>
<li>cin<br>输入时，以空格、tab、回车作为分隔符。当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，<strong>cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&gt;&gt;不做处理</strong></li>
<li>cin.getline()<br>用于读取字符串，读到的字符串是c++风格的string类型。<br>cin.getline默认读取到回车时终止，并将回车符号转换为\0存入字符串，同时将回车符从缓冲区中删除。空格也会被读取<br>函数原型有两个：   </li>
</ul>
</li>
</ul>
<p><em>//s是存放读取到的字符串的数组，count是读取长度<br>istream&amp; getline(char</em> s, streamsize count); //默认以换行符结束<br>istream&amp; getline(char* s, streamsize count, char delim);//delim为规定的结束符*   </p>
<ul>
<li>getline()<br>getline(cin, str)与cin.getline(str, num)作用相同，都可以读取空格，默认以回车结束。但是cin.getline的str要求是字符数组，且必须要指定num。而getline的str是string类型的变量，而且不需要指定长度。所以推荐使用getline。</li>
<li>cin.get<br>使用cin.get读取字符串时，可以这样使用：<br>ch = cin.get();<br>cin.get(ch);<br>或者直接cin.get()表示不将输入读取到任何变量，只是用来阻塞或者清除多余回车<br>cin.get()也可以用于读取字符串，不建议使用</li>
<li>gets<br>不建议使用</li>
<li>综上所述，普通输入用cin，读取字符串用getline()，读取字符用cin.get()<ul>
<li>ios::sync_with_stdio(false)可以用来提高cin和cout的速度</li>
<li>C++ 字符串<br>Cpp提供了两种类型的字符串表示形式：一种是C风格的字符串，另一种是C++风格的string类型字符串 </li>
<li>头文件<string><cstring>之间的区别：cstring是c语言中的string.h的c++版本，用法相同，用于处理C语言形式的字符串。引用string后就可以使用string类型（其实不引用也可以使用string类型），同时可以使用下面的string类中的函数。在处理字符串时，需要注意C++与c类型的字符串之间的区别，平时尽量只使用c++类型的字符串，必要时可以使用string类中的data()或者c_str()函数将string类型的字符串转化为c类型的字符串，两种方法的不同之处是，c_str()转换后会在最后加\0，而data()不会。</li>
<li>c_str()应该这样用: char c[20]; string s=”1234”; strcpy(c,s.c_str()); 这样才不会出错,c_str()返回的是一个临时指针,不能对其进行操作</li>
<li>C++ string类   </li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/Draymonder/p/6944479.html" target="_blank" rel="noopener">https://www.cnblogs.com/Draymonder/p/6944479.html</a></li>
<li>构造函数(Constructors)<br>语法:<br>string();<br>string( size_type length, char ch );<br>string( const char *str );参数是c形式字符串，可以实现c形式字符串到c++形式字符串的转换<br>string( const char *str, size_type length );<br>string( string &amp;str, size_type index, size_type length );<br>string( input_iterator start, input_iterator end );<br>字符串的构造函数创建一个新字符串，包括:<br>以length为长度的ch的拷贝（即length个ch）<br>以str为初值 (长度任意),<br>以index为索引开始的子串，长度为length, 或者<br>以从start到end的元素为初值.<br>例如,<br>string str1( 5, ‘c’ );<br>string str2( “Now is the time…” );<br>string str3( str2, 11, 4 );<br>cout &lt;&lt; str1 &lt;&lt; endl;<br>cout &lt;&lt; str2 &lt;&lt; endl;<br>cout &lt;&lt; str3 &lt;&lt; endl;<br>显示<br>ccccc<br>Now is the time…<br>time   </li>
<li>对字符串赋值方法很多，例如：<br>string s1(“hello”), s2;<br>s2 = s1;<br>或者用assign函数s2.assign(s1)</li>
<li>求字符串长度可以用.length()也可以用.size()</li>
<li>除了使用+、+=来连接字符串之外，还可以用append()函数在字符串末尾添加内容</li>
<li>字符串比较可以使用&gt; &lt; &gt;= &lt;=等等，比较的不是字符串长度，而是一位一位地比较字母的大小。<ul>
<li>201709_2：需要进行多重排序时，可以将排序依据包装到一个结构体里面，然后编写cmp函数，利用sort函数进行排序</li>
<li>什么是标准模板库（STL）？<br>(1)C++标准模板库与C++标准库的关系<br>C++标准模板库其实属于C++标准库的一部分，C++标准模板库主要是定义了标准模板的定义与声明，而这些模板主要都是<br>类模板，我们可以调用这些模板来定义一个具体的类；与之前的自己手动创建一个函数模版或者是类模板不一样，我们使用了<br>STL就不用自己来创建模板了，这些模板都定义在标准模板库中，我们只需要学会怎么使用这些类模板来定义一个具体的类，<br>然后能够使用类提供的各种方法来处理数据。<br>(2)STL六大组件：容器（containers）、算法（algorithms）、迭代器（iterators）、函数对象（functors）、适配器（adapters）、分配器（allocators）</li>
<li>在C++中，结构体可以有构造函数。例如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ROLE&#123;</span><br><span class="line">    int health;</span><br><span class="line">    int attack;</span><br><span class="line">    ROLE()&#123;health &#x3D; 0; attack &#x3D; -1;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int r,c,dist;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(int r,int c,int dist):r(r),c(c),dist(dist)&#123;&#125;&#x2F;&#x2F;r(r)表示将r赋值给变量r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在C++中，定义结构体时不需要使用typedef，创建一个新的结构体变量的时候也不需要再加上struct，直接使用结构体的名字即可。例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct A &#123; &#x2F;&#x2F; 声明结构体</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a_st;  &#x2F;&#x2F;定义结构体</span><br><span class="line">A* a_p; &#x2F;&#x2F; 定义结构体指针</span><br></pre></td></tr></table></figure></li>
<li>使用#ifdef提高效率，例如<br>int main()<br>{<br>#ifdef LOCAL<br>freopen(“datain.txt”,”r”,stdin);<br>#endif // LOCAL<br>run();<br>ans();<br>return 0;<br>}<br>如果在前面已经有#define LOCAL，那么就会执行freopen，否则就直接执行endif后面的语句。在本地测试时，要在前面加上#define LOCAL，这样只需要将测试用例写到datain.txt中，不需要每次都手动输入。提交时，将#define LOCAL删除。</li>
<li>使用stringstream进行数据转换（int-&gt;string）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    std::string result;</span><br><span class="line">    int i &#x3D; 1000;</span><br><span class="line">    stream &lt;&lt; i; &#x2F;&#x2F;将int输入流</span><br><span class="line">    stream &gt;&gt; result; &#x2F;&#x2F;从stream中抽取前面插入的int值</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; &#x2F;&#x2F; print the string &quot;1000&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stringstream进行数据类型转换(int-&gt;char*)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    char result[8] ;</span><br><span class="line">    stream &lt;&lt; 8888; &#x2F;&#x2F;向stream中插入8888</span><br><span class="line">    stream &gt;&gt; result; &#x2F;&#x2F;抽取stream中的值到result</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; &#x2F;&#x2F; 屏幕显示 &quot;8888&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stringstream进行数据类型转换()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃i nclude &lt;iostream&gt; </span><br><span class="line">＃i nclude &lt;sstream&gt; </span><br><span class="line">＃i nclude &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">stringstream sstr; </span><br><span class="line">string name &#x3D; &quot;colinguan&quot;; </span><br><span class="line">char cname[200]; </span><br><span class="line">sstr&lt;&lt;name; </span><br><span class="line">sstr&gt;&gt;cname; </span><br><span class="line">cout&lt;&lt;cname; </span><br><span class="line">system(&quot;pause&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重复使用同一个stringstream进行数据转换时，必须调用其成员函数clear()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    int first, second;</span><br><span class="line">    stream&lt;&lt; &quot;456&quot;; &#x2F;&#x2F;插入字符串</span><br><span class="line">    stream &gt;&gt; first; &#x2F;&#x2F;转换成int</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; std::endl;</span><br><span class="line">    stream.clear(); &#x2F;&#x2F;在进行多次转换前，必须清除stream</span><br><span class="line">    stream &lt;&lt; true; &#x2F;&#x2F;插入bool值</span><br><span class="line">    stream &gt;&gt; second; &#x2F;&#x2F;提取出int</span><br><span class="line">    std::cout &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>stringstream有两种构造函数，一种是没有任何参数；另一种是带有参数。带有参数时，其参数将直接成为构造的stringstream对象的内容。另外，stringstream类还有一个成员函数put()。用于向stringstream中添加内容。当使用没有参数的方法构造stringstream时，使用put()函数则直接向stringstream尾部添加。使用带参数的方式时，使用put()函数就会从覆盖之前的内容。例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;sstream&gt; </span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">string cc &#x3D; &quot;ccc&quot;;</span><br><span class="line">stringstream ostr;</span><br><span class="line">ostr &lt;&lt; cc;</span><br><span class="line">ostr.put(&#39;d&#39;); </span><br><span class="line">ostr.put(&#39;e&#39;); </span><br><span class="line">ostr&lt;&lt;&quot;fg&quot;; </span><br><span class="line">string gstr &#x3D; ostr.str(); </span><br><span class="line">cout&lt;&lt;gstr&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">char a; </span><br><span class="line">ostr&gt;&gt;a; </span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;cccdefg</span><br><span class="line">&#x2F;&#x2F;c</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;sstream&gt; </span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main()   </span><br><span class="line">&#123; </span><br><span class="line">stringstream ostr(&quot;ccc&quot;);</span><br><span class="line">ostr.put(&#39;d&#39;); </span><br><span class="line">ostr.put(&#39;e&#39;); </span><br><span class="line">ostr&lt;&lt;&quot;fg&quot;; </span><br><span class="line">string gstr &#x3D; ostr.str(); </span><br><span class="line">cout&lt;&lt;gstr&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">char a; </span><br><span class="line">ostr&gt;&gt;a; </span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;defg</span><br><span class="line">&#x2F;&#x2F;d</span><br></pre></td></tr></table></figure></li>
<li>广度优先搜索模版<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BFS(int s)&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        取出队首元素top;</span><br><span class="line">        访问队首元素top;&#x2F;&#x2F;（访问可以是任何操作，例如打印输出）</span><br><span class="line">        将队首元素出队;</span><br><span class="line">        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个BFS的例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*问题描述：给出一个m*n的矩阵，矩阵中的元素为0或1，称位置（x，y）与其上下左右</span><br><span class="line">四个位置是相邻的，如果矩阵中有若干个1是相邻的（不必两两相邻），那么称这些1构成一个块。求给定矩阵中块的个数</span><br><span class="line">*&#x2F; </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define LOCAL</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int matrix[maxn][maxn];</span><br><span class="line">bool inq[maxn][maxn];</span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool judge(int x, int y)&#123;</span><br><span class="line">	if(x&gt;&#x3D;n || x&lt;0 || y&gt;&#x3D;m || y&lt;0)</span><br><span class="line">		return false;</span><br><span class="line">	if(matrix[x][y] &#x3D;&#x3D; 0 || inq[x][y] &#x3D;&#x3D; true)</span><br><span class="line">		return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;bool inq[maxn][maxn] &#x3D; &#123;false&#125;;</span><br><span class="line">	#ifdef LOCAL</span><br><span class="line">	freopen(&quot;data.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	#endif</span><br><span class="line">	int i, j, k, newx, newy, cnt&#x3D;0;</span><br><span class="line">	Node node;</span><br><span class="line">	queue&lt;Node&gt; q;</span><br><span class="line">	int plusx[4] &#x3D; &#123;0, 0, 1, -1&#125;;</span><br><span class="line">	int plusy[4] &#x3D; &#123;1, -1, 0, 0&#125;;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cin.get();</span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		for(j&#x3D;0; j&lt;m; j++)&#123;</span><br><span class="line">			cin &gt;&gt; matrix[i][j];</span><br><span class="line">			cin.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		for(j&#x3D;0; j&lt;m; j++)&#123;</span><br><span class="line">			if(judge(i, j))&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				node.x &#x3D; i;</span><br><span class="line">				node.y &#x3D; j;</span><br><span class="line">				q.push(node);</span><br><span class="line">				while(!q.empty())&#123;</span><br><span class="line">					Node top &#x3D; q.front();</span><br><span class="line">					q.pop();</span><br><span class="line">					for(k&#x3D;0; k&lt;4; k++)&#123;</span><br><span class="line">						newx &#x3D; top.x + plusx[k];</span><br><span class="line">						newy &#x3D; top.y + plusy[k];</span><br><span class="line">						node.x &#x3D; newx;</span><br><span class="line">						node.y &#x3D; newy;</span><br><span class="line">						if(judge(newx, newy))&#123;</span><br><span class="line">							q.push(node);</span><br><span class="line">							inq[node.x][node.y] &#x3D; true;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个DFS的例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*问题描述：有n件物品，每件物品的重量为w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为v的包中，使得在选入背包的物品不超过容量的情况下，让背包中物品的总价值最大，求最大价值</span><br><span class="line">*&#x2F;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define LOCAL</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line"></span><br><span class="line">int n, v;</span><br><span class="line">int maxvalue &#x3D; 0;</span><br><span class="line">int w[maxn];</span><br><span class="line">int c[maxn];</span><br><span class="line">void DFS(int index, int sumw, int sumc)&#123;</span><br><span class="line">	if(index &#x3D;&#x3D; n)&#123;</span><br><span class="line">		if(sumw &lt;&#x3D; v &amp;&amp; sumc &gt; maxvalue)&#123;</span><br><span class="line">			maxvalue &#x3D; sumc;</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(index+1, sumw, sumc);</span><br><span class="line">	DFS(index+1, sumw+w[index], sumc+c[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	#ifdef LOCAL</span><br><span class="line">	freopen(&quot;data_DFS.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">	#endif</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">	cin.get();</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; w[i];</span><br><span class="line">		cin.get();</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; c[i];</span><br><span class="line">		cin.get();</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(0, 0, 0);</span><br><span class="line">	cout &lt;&lt; maxvalue;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>fill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(vec.begin(), vec.end(), val); val为将要替换的值。需要头文件<algorithm></li>
<li>使用nullptr来代替NULL</li>
<li>关于new和malloc</li>
</ul>
</li>
<li>申请内存时的位置可能会不同</li>
<li>使用new时会对对象进行初始化，例如申请了一个结构体的空间，会对结构体中的变量进行初始化。如果结构体中有string变量，但是使用的是malloc的话，会因为没有给string进行初始化而bomb</li>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型</li>
<li>C++提供了new[]与delete[]来专门处理数组类型:<br>A * ptr = new A[10];//分配10个A对象<br>使用new[]分配的内存必须使用delete[]进行释放：<br>delete [] ptr<br>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</li>
<li>使用new申请的空间，使用delete进行释放</li>
<li>特别大的数组不要在函数里面开，有可能会栈溢出。可以定义成全局变量。</li>
</ul>
]]></content>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
</search>
